{"version":3,"sources":["scoring.js"],"names":["define","adjacency_graphs","calc_average_degree","k","graph","average","key","n","neighbors","len","o","results","length","push","nCk","d","r","ref","log10","Math","log","log2","factorial","f","i","most_guessable_match_sequence","password","matches","_exclude_additive","bruteforce_update","guesses","l","len1","len2","m","make_bruteforce_match","matches_by_j","optimal","optimal_l","optimal_match_sequence","q","ref1","u","unwind","update","w","j","sort","m1","m2","pi","g","competing_g","competing_l","this","estimate_guesses","pow","last_m","results1","parseInt","pattern","token","slice","candidate_g","candidate_l","unshift","guesses_log10","sequence","match","min_guesses","bruteforce","bruteforce_guesses","dictionary","dictionary_guesses","spatial","spatial_guesses","repeat","repeat_guesses","sequence_guesses","regex","regex_guesses","date","date_guesses","call","max","Number","POSITIVE_INFINITY","MAX_VALUE","MIN_SUBMATCH_GUESSES_SINGLE_CHAR","MIN_SUBMATCH_GUESSES_MULTI_CHAR","base_guesses","repeat_count","first_chr","charAt","ascending","MIN_YEAR_SPACE","REFERENCE_YEAR","Date","getFullYear","char_class_bases","year_space","alpha_lower","alpha_upper","alpha","alphanumeric","digits","symbols","regex_name","abs","regex_match","year","separator","KEYBOARD_AVERAGE_DEGREE","qwerty","KEYPAD_AVERAGE_DEGREE","keypad","KEYBOARD_STARTING_POSITIONS","KEYPAD_STARTING_POSITIONS","L","S","U","ref2","ref3","s","shifted_variations","t","turns","min","shifted_count","reversed_variations","rank","uppercase_variations","l33t_variations","reversed","START_UPPER","END_UPPER","ALL_UPPER","ALL_LOWER","chr","variations","word","toLowerCase","split","chrs","possibilities","subbed","unsubbed","l33t","sub"],"mappings":";;;;;;;AAAAA,QACE,sBACA,SAASC,GAET,IAAsJC,EAAqBC,EAyjB3K,OArjBAD,EAAsB,SAASE,GAC7B,IAAIC,EAASF,EAAGG,EAAKC,EAAGC,EAExB,IAAKF,KADLD,EAAU,EACED,EACVI,EAAYJ,EAAME,GAClBD,GAAY,WACV,IAAII,EAAKC,EAAGC,EAEZ,IADAA,KACKD,EAAI,EAAGD,EAAMD,EAAUI,OAAQF,EAAID,EAAKC,KAC3CH,EAAIC,EAAUE,KAEZC,EAAQE,KAAKN,GAGjB,OAAOI,EATE,GAULC,OAWR,OATAP,GAAY,WACV,IAAIM,EAEJ,IAAKR,KADLQ,KACUP,EACJA,EAAMD,GACVQ,EAAQE,KAAKV,GAEf,OAAOQ,EAPE,GAQLC,QAIiB,GAEa,IAEH,GAED,IAGhCE,IAAK,SAASP,EAAGJ,GACf,IAAIY,EAAGL,EAAGM,EAAGC,EACb,GAAId,EAAII,EAEN,OAAO,EAET,GAAU,IAANJ,EACF,OAAO,EAGT,IADAa,EAAI,EACCD,EAAIL,EAAI,EAAGO,EAAMd,EAAI,GAAKc,EAAMP,GAAKO,EAAMP,GAAKO,EAAMF,EAAI,GAAKE,IAAQP,IAAMA,EAChFM,GAAKT,EACLS,GAAKD,EACLR,GAAK,EAEP,OAAOS,GAETE,MAAO,SAASX,GACd,OAAOY,KAAKC,IAAIb,GAAKY,KAAKC,IAAI,KAEhCC,KAAM,SAASd,GACb,OAAOY,KAAKC,IAAIb,GAAKY,KAAKC,IAAI,IAEhCE,UAAW,SAASf,GAClB,IAAIgB,EAAGC,EAAGd,EAAGO,EACb,GAAIV,EAAI,EAEN,OAAO,EAGT,IADAgB,EAAI,EACCC,EAAId,EAAI,EAAGO,EAAMV,EAAI,GAAKU,EAAMP,GAAKO,EAAMP,GAAKO,EAAMO,EAAI,GAAKP,IAAQP,IAAMA,EAChFa,GAAKC,EAEP,OAAOD,GAkCTE,8BAA+B,SAASC,EAAUC,EAASC,GAAoB,GAC7E,IAAOC,EAAmBC,EAAS3B,EAAG4B,EAAGtB,EAAKuB,EAAMC,EAAWC,EAAGC,EAAuBC,EAAc7B,EAAGG,EAAG2B,EAASC,EAAWC,EAAwBC,EAAGvB,EAAKwB,EAAMC,EAAGC,EAAQC,EAAQC,EAW1L,IAVAtC,EAAImB,EAASd,OAEbwB,EAAe,WACb,IAAI1B,EAAGO,EAAKN,EAEZ,IADAA,KACSD,EAAI,EAAGO,EAAMV,EAAI,GAAKU,EAAMP,EAAIO,EAAMP,EAAIO,EAAU,GAAKA,IAAQP,IAAMA,EAC9EC,EAAQE,SAEV,OAAOF,EANM,GAQVD,EAAI,EAAGD,EAAMkB,EAAQf,OAAQF,EAAID,EAAKC,IAEzC0B,GADAF,EAAIP,EAAQjB,IACGoC,GAAGjC,KAAKqB,GAGzB,IAAKM,EAAI,EAAGR,EAAOI,EAAaxB,OAAQ4B,EAAIR,EAAMQ,IAC1CJ,EAAaI,GACfO,KAAK,SAASC,EAAIC,GACpB,OAAOD,EAAGxB,EAAIyB,EAAGzB,IA2IrB,IAxIAa,GAKEH,EAAG,WACD,IAAIjB,EAAKN,EAAS+B,EAElB,IADA/B,KACS+B,EAAI,EAAGzB,EAAMV,EAAI,GAAKU,EAAMyB,EAAIzB,EAAMyB,EAAIzB,EAAU,GAAKA,IAAQyB,IAAMA,EAC9E/B,EAAQE,SAEV,OAAOF,EANN,GAUHuC,GAAI,WACF,IAAIjC,EAAKN,EAAS+B,EAElB,IADA/B,KACS+B,EAAI,EAAGzB,EAAMV,EAAI,GAAKU,EAAMyB,EAAIzB,EAAMyB,EAAIzB,EAAU,GAAKA,IAAQyB,IAAMA,EAC9E/B,EAAQE,SAEV,OAAOF,EANL,GASJwC,EAAG,WACD,IAAIlC,EAAKN,EAAS+B,EAElB,IADA/B,KACS+B,EAAI,EAAGzB,EAAMV,EAAI,GAAKU,EAAMyB,EAAIzB,EAAMyB,EAAIzB,EAAU,GAAKA,IAAQyB,IAAMA,EAC9E/B,EAAQE,SAEV,OAAOF,EANN,IAWLiC,EAAS,EAACV,EAAGH,KACX,IAAIqB,EAAaC,EAAaF,EAAGhD,EAAG+C,EAAIjC,EAkBxC,IAAKoC,KAjBLlD,EAAI+B,EAAEY,EACNI,EAAKI,KAAKC,iBAAiBrB,EAAGR,GAC1BK,EAAI,IAINmB,GAAMb,EAAQa,GAAGhB,EAAEV,EAAI,GAAGO,EAAI,IAGhCoB,EAAIG,KAAKhC,UAAUS,GAAKmB,EACnBtB,IACHuB,GAAKhC,KAAKqC,IAjJoB,IAiJqBzB,EAAI,IAEzDd,EAAMoB,EAAQc,EAAEhD,GAMd,GADAiD,EAAcnC,EAAIoC,KACdA,EAActB,IAGdqB,GAAeD,EACjB,OAMJ,OAFAd,EAAQc,EAAEhD,GAAG4B,GAAKoB,EAClBd,EAAQH,EAAE/B,GAAG4B,GAAKG,EACXG,EAAQa,GAAG/C,GAAG4B,GAAKmB,IAG5BrB,EAAoB,CAAC1B,IACnB,IAAIqB,EAAGO,EAAG0B,EAAQxC,EAAKN,EAAS+B,EAKhC,IAHAR,EAAIC,EAAsB,EAAGhC,GAC7ByC,EAAOV,EAAG,GACVvB,KACKa,EAAIkB,EAAI,EAAGzB,EAAMd,EAAI,GAAKc,EAAMyB,GAAKzB,EAAMyB,GAAKzB,EAAMO,EAAI,GAAKP,IAAQyB,IAAMA,EAIhFR,EAAIC,EAAsBX,EAAGrB,GAC7BQ,EAAQE,KAAK,WACX,IAAI4B,EAAMiB,EAGV,IAAK3B,KADL2B,KADAjB,EAAOJ,EAAQH,EAAEV,EAAI,GAGnBiC,EAAShB,EAAKV,GACdA,EAAI4B,SAAS5B,GACU,eAAnB0B,EAAOG,SAQXF,EAAS7C,KAAK+B,EAAOV,EAAGH,EAAI,IAE9B,OAAO2B,EAjBI,IAoBf,OAAO/C,IAGTwB,EAAwB,EAACX,EAAGsB,MAExBc,QAAS,aACTC,MAAOnC,EAASoC,MAAMtC,GAAIsB,EAAI,GAAK,KACnCtB,EAAGA,EACHsB,EAAGA,KAKPH,EAAS,CAACpC,IACR,IAAIwD,EAAaC,EAAab,EAAGhD,EAAG4B,EAAGQ,EAAwBtB,EAO/D,IAAK+C,KANLzB,KACApC,EAAII,EAAI,EAERwB,OAAI,EACJoB,EAAI,SACJlC,EAAMoB,EAAQc,EAAEhD,IAEd4D,EAAc9C,EAAI+C,IACAb,IAChBpB,EAAIiC,EACJb,EAAIY,GAGR,KAAO5D,GAAK,GACV+B,EAAIG,EAAQH,EAAE/B,GAAG4B,GACjBQ,EAAuB0B,QAAQ/B,GAC/B/B,EAAI+B,EAAEV,EAAI,EACVO,IAEF,OAAOQ,IAEJpC,EAAIuC,EAAI,EAAGzB,EAAMV,EAAI,GAAKU,EAAMyB,EAAIzB,EAAMyB,EAAIzB,EAAMd,EAAI,GAAKc,IAAQyB,IAAMA,EAAG,CAEjF,IAAKG,EAAI,EAAGZ,GADZQ,EAAOL,EAAajC,IACIS,OAAQiC,EAAIZ,EAAMY,IAExC,IADAX,EAAIO,EAAKI,IACHrB,EAAI,EACR,IAAKO,KAAKM,EAAQH,EAAEA,EAAEV,EAAI,GACxBO,EAAI4B,SAAS5B,GACba,EAAOV,EAAGH,EAAI,QAGhBa,EAAOV,EAAG,GAGdL,EAAkB1B,GAUpB,OAPAmC,GADAC,EAAyBI,EAAOpC,IACGK,OAGjCkB,EADsB,IAApBJ,EAASd,OACD,EAEAyB,EAAQc,EAAE5C,EAAI,GAAG+B,IAI3BZ,SAAUA,EACVI,QAASA,EACToC,cAAeZ,KAAKpC,MAAMY,GAC1BqC,SAAU5B,IAMdgB,iBAAkB,SAASa,EAAO1C,GAChC,IAA0BI,EAASuC,EACnC,OAAqB,MAAjBD,EAAMtC,QACDsC,EAAMtC,SAEfuC,EAAc,EACVD,EAAMP,MAAMjD,OAASc,EAASd,SAChCyD,EAAqC,IAAvBD,EAAMP,MAAMjD,OAhRG,GAED,IAyR9BkB,GAREwC,WAAYhB,KAAKiB,mBACjBC,WAAYlB,KAAKmB,mBACjBC,QAASpB,KAAKqB,gBACdC,OAAQtB,KAAKuB,eACbV,SAAUb,KAAKwB,iBACfC,MAAOzB,KAAK0B,cACZC,KAAM3B,KAAK4B,cAEkBd,EAAMR,SAASuB,KAAK7B,KAAMc,GACzDA,EAAMtC,QAAUX,KAAKiE,IAAItD,EAASuC,GAClCD,EAAMF,cAAgBZ,KAAKpC,MAAMkD,EAAMtC,SAChCsC,EAAMtC,UAEfyC,mBAAoB,SAASH,GAC3B,IAAItC,EAASuC,EAMb,OALAvC,EAAUX,KAAKqC,IAtSM,GAsSsBY,EAAMP,MAAMjD,WACvCyE,OAAOC,oBACrBxD,EAAUuD,OAAOE,WAEnBlB,EAAqC,IAAvBD,EAAMP,MAAMjD,OAAe4E,GAAuCC,GACzEtE,KAAKiE,IAAItD,EAASuC,IAE3BQ,eAAgB,SAAST,GACvB,OAAOA,EAAMsB,aAAetB,EAAMuB,cAEpCb,iBAAkB,SAASV,GACzB,IAAIsB,EAAcE,EAmBlB,OAfEF,EADgB,OAFlBE,EAAYxB,EAAMP,MAAMgC,OAAO,KAEQ,MAAdD,GAAmC,MAAdA,GAAmC,MAAdA,GAAmC,MAAdA,GAAmC,MAAdA,GAAmC,MAAdA,EACjH,EAEXA,EAAUxB,MAAM,MACH,GAIA,GAGdA,EAAM0B,YAGTJ,GAAgB,GAEXA,EAAetB,EAAMP,MAAMjD,QAEpCmF,eAAgB,GAChBC,gBAAgB,IAAIC,MAAOC,cAC3BlB,cAAe,SAASZ,GACtB,IAAI+B,EAAkBC,EAStB,GARAD,GACEE,YAAa,GACbC,YAAa,GACbC,MAAO,GACPC,aAAc,GACdC,OAAQ,GACRC,QAAS,IAEPtC,EAAMuC,cAAcR,EACtB,OAAOhF,KAAKqC,IAAI2C,EAAiB/B,EAAMuC,YAAavC,EAAMP,MAAMjD,QAEhE,OAAQwD,EAAMuC,YACZ,IAAK,cAKH,OAFAP,EAAajF,KAAKyF,IAAIjD,SAASS,EAAMyC,YAAY,IAAMvD,KAAK0C,gBAC5DI,EAAajF,KAAKiE,IAAIgB,EAAY9C,KAAKyC,kBAK/Cb,aAAc,SAASd,GACrB,IAAItC,EAQJ,OALAA,EAAuB,IADVX,KAAKiE,IAAIjE,KAAKyF,IAAIxC,EAAM0C,KAAOxD,KAAK0C,gBAAiB1C,KAAKyC,gBAEnE3B,EAAM2C,YAERjF,GAAW,GAENA,GAETkF,wBAAyB9G,EAAoBD,EAAiBgH,QAE9DC,sBAAuBhH,EAAoBD,EAAiBkH,QAC5DC,4BAA8B,WAC5B,IAAInG,EAAKN,EAGT,IAAKR,KADLQ,KADAM,EAAMhB,EAAiBgH,OAGjBhG,EAAId,GACRQ,EAAQE,KAAKV,GAEf,OAAOQ,EARoB,GASvBC,OACNyG,0BAA4B,WAC1B,IAAIpG,EAAKN,EAGT,IAAKR,KADLQ,KADAM,EAAMhB,EAAiBkH,OAGjBlG,EAAId,GACRQ,EAAQE,KAAKV,GAEf,OAAOQ,EARkB,GASrBC,OACN+D,gBAAiB,SAASP,GACxB,IAAIkD,EAAGC,EAAGC,EAAGzG,EAAGe,EAASN,EAAGsB,EAAGpC,EAAmB8B,EAAGvB,EAAKwB,EAAMgF,EAAMC,EAAMC,EAAGC,EAAoBC,EAAGnF,EAYtG,IAX4B,YAAvBzB,EAAMmD,EAAMhE,QAA+B,WAARa,GACtC0G,EAAIrE,KAAK8D,4BACTrG,EAAIuC,KAAK0D,0BAETW,EAAIrE,KAAK+D,0BACTtG,EAAIuC,KAAK4D,uBAEXpF,EAAU,EACVwF,EAAIlD,EAAMP,MAAMjD,OAChBiH,EAAIzD,EAAM0D,MAELtG,EAAId,EAAI,EAAG+B,EAAO6E,EAAI,GAAK7E,EAAO/B,GAAK+B,EAAO/B,GAAK+B,EAAOjB,EAAI,GAAKiB,IAAS/B,IAAMA,EAErF,IAAKoC,EAAIN,EAAI,EAAGiF,EADCtG,KAAK4G,IAAIF,EAAGrG,EAAI,GACO,GAAKiG,EAAOjF,GAAKiF,EAAOjF,GAAKiF,EAAO3E,EAAI,GAAK2E,IAASjF,IAAMA,EAClGV,GAAWwB,KAAKxC,IAAIU,EAAI,EAAGsB,EAAI,GAAK6E,EAAIxG,KAAKqC,IAAIzC,EAAG+B,GAKxD,GAAIsB,EAAM4D,cAGR,GAFAT,EAAInD,EAAM4D,cACVR,EAAIpD,EAAMP,MAAMjD,OAASwD,EAAM4D,cACrB,IAANT,GAAiB,IAANC,EACb1F,GAAW,MACN,CAEL,IADA8F,EAAqB,EAChBpG,EAAIkB,EAAI,EAAGgF,EAAOvG,KAAK4G,IAAIR,EAAGC,GAAK,GAAKE,EAAOhF,GAAKgF,EAAOhF,GAAKgF,EAAOlG,EAAI,GAAKkG,IAAShF,IAAMA,EAClGkF,GAAsBtE,KAAKxC,IAAIyG,EAAIC,EAAGhG,GAExCM,GAAW8F,EAGf,OAAO9F,GAET2C,mBAAoB,SAASL,GAC3B,IAAI6D,EAKJ,OAJA7D,EAAMsB,aAAetB,EAAM8D,KAC3B9D,EAAM+D,qBAAuB7E,KAAK6E,qBAAqB/D,GACvDA,EAAMgE,gBAAkB9E,KAAK8E,gBAAgBhE,GAC7C6D,EAAsB7D,EAAMiE,SAAY,EAAK,EACtCjE,EAAMsB,aAAetB,EAAM+D,qBAAuB/D,EAAMgE,gBAAkBH,GAEnFK,YAAa,iBACbC,UAAW,iBACXC,UAAW,YACXC,UAAW,YACXN,qBAAsB,SAAS/D,GAC7B,IAAIkD,EAAGE,EAAGkB,EAAKlH,EAAGf,EAAKC,EAAG8B,EAAGvB,EAAKwB,EAAMsC,EAAO4D,EAAYC,EAE3D,IADAA,EAAOxE,EAAMP,OACJO,MAAMd,KAAKmF,YAAcG,EAAKC,gBAAkBD,EACvD,OAAO,EAMT,IAAKlI,EAAI,EAAGD,GAJZQ,GAAOqC,KAAKgF,YAAahF,KAAKiF,UAAWjF,KAAKkF,YAIxB5H,OAAQF,EAAID,EAAKC,IAErC,GADAqE,EAAQ9D,EAAIP,GACRkI,EAAKxE,MAAMW,GACb,OAAO,EA+BX,IAzBAyC,EAAK,WACH,IAAIxF,EAAMQ,EAAGC,EAAM9B,EAGnB,IADAA,KACK6B,EAAI,EAAGR,GAFZS,EAAOmG,EAAKE,MAAM,KAEMlI,OAAQ4B,EAAIR,EAAMQ,KACxCkG,EAAMjG,EAAKD,IACH4B,MAAM,UACZzD,EAAQE,KAAK6H,GAGjB,OAAO/H,EAVL,GAWEC,OACN0G,EAAK,WACH,IAAItF,EAAMQ,EAAGC,EAAM9B,EAGnB,IADAA,KACK6B,EAAI,EAAGR,GAFZS,EAAOmG,EAAKE,MAAM,KAEMlI,OAAQ4B,EAAIR,EAAMQ,KACxCkG,EAAMjG,EAAKD,IACH4B,MAAM,UACZzD,EAAQE,KAAK6H,GAGjB,OAAO/H,EAVL,GAWEC,OACN+H,EAAa,EACRnH,EAAIgB,EAAI,EAAGC,EAAOtB,KAAK4G,IAAIP,EAAGF,GAAK,GAAK7E,EAAOD,GAAKC,EAAOD,GAAKC,EAAOjB,EAAI,GAAKiB,IAASD,IAAMA,EAClGmG,GAAcrF,KAAKxC,IAAI0G,EAAIF,EAAG9F,GAEhC,OAAOmH,GAETP,gBAAiB,SAAShE,GACxB,IAAImD,EAAGC,EAAGkB,EAAKK,EAAMvH,EAAGd,EAAMsI,EAAe/H,EAAKwB,EAAMwG,EAAQC,EAAUP,EAC1E,IAAKvE,EAAM+E,KACT,OAAO,EAIT,IAAKF,KAFLN,EAAa,EACb1H,EAAMmD,EAAMgF,IA2BV,GAzBAF,EAAWjI,EAAIgI,GAEfF,EAAO3E,EAAMP,MAAMgF,cAAcC,MAAM,IACvCvB,EAAK,WACH,IAAI9G,EAAKC,EAAGC,EAEZ,IADAA,KACKD,EAAI,EAAGD,EAAMsI,EAAKnI,OAAQF,EAAID,EAAKC,KACtCgI,EAAMK,EAAKrI,MACCuI,GACVtI,EAAQE,KAAK6H,GAGjB,OAAO/H,EATL,GAUEC,OACN4G,EAAK,WACH,IAAI/G,EAAKC,EAAGC,EAEZ,IADAA,KACKD,EAAI,EAAGD,EAAMsI,EAAKnI,OAAQF,EAAID,EAAKC,KACtCgI,EAAMK,EAAKrI,MACCwI,GACVvI,EAAQE,KAAK6H,GAGjB,OAAO/H,EATL,GAUEC,OACI,IAAN2G,GAAiB,IAANC,EAIbmB,GAAc,MACT,CAKL,IADAK,EAAgB,EACXxH,EAAId,EAAI,EAAG+B,EAFZtB,KAAK4G,IAAIP,EAAGD,GAEW,GAAK9E,EAAO/B,GAAK+B,EAAO/B,GAAK+B,EAAOjB,EAAI,GAAKiB,IAAS/B,IAAMA,EACrFsI,GAAiB1F,KAAKxC,IAAI0G,EAAID,EAAG/F,GAEnCmH,GAAcK,EAGlB,OAAOL","file":"../scoring.js","sourcesContent":["define([\n  './adjacency_graphs'\n],function(adjacency_graphs){\n\n  var BRUTEFORCE_CARDINALITY, MIN_GUESSES_BEFORE_GROWING_SEQUENCE, MIN_SUBMATCH_GUESSES_MULTI_CHAR, MIN_SUBMATCH_GUESSES_SINGLE_CHAR, adjacency_graphs, calc_average_degree, k, scoring, v;\n\n  // on qwerty, 'g' has degree 6, being adjacent to 'ftyhbv'. '\\' has degree 1.\n  // this calculates the average over all keys.\n  calc_average_degree = function(graph) {\n    var average, k, key, n, neighbors, v;\n    average = 0;\n    for (key in graph) {\n      neighbors = graph[key];\n      average += ((function() {\n        var len, o, results;\n        results = [];\n        for (o = 0, len = neighbors.length; o < len; o++) {\n          n = neighbors[o];\n          if (n) {\n            results.push(n);\n          }\n        }\n        return results;\n      })()).length;\n    }\n    average /= ((function() {\n      var results;\n      results = [];\n      for (k in graph) {\n        v = graph[k];\n        results.push(k);\n      }\n      return results;\n    })()).length;\n    return average;\n  };\n\n  BRUTEFORCE_CARDINALITY = 10;\n\n  MIN_GUESSES_BEFORE_GROWING_SEQUENCE = 10000;\n\n  MIN_SUBMATCH_GUESSES_SINGLE_CHAR = 10;\n\n  MIN_SUBMATCH_GUESSES_MULTI_CHAR = 50;\n\n  scoring = {\n    nCk: function(n, k) {\n      var d, o, r, ref;\n      if (k > n) {\n        // http://blog.plover.com/math/choose.html\n        return 0;\n      }\n      if (k === 0) {\n        return 1;\n      }\n      r = 1;\n      for (d = o = 1, ref = k; (1 <= ref ? o <= ref : o >= ref); d = 1 <= ref ? ++o : --o) {\n        r *= n;\n        r /= d;\n        n -= 1;\n      }\n      return r;\n    },\n    log10: function(n) {\n      return Math.log(n) / Math.log(10); // IE doesn't support Math.log10 :(\n    },\n    log2: function(n) {\n      return Math.log(n) / Math.log(2);\n    },\n    factorial: function(n) {\n      var f, i, o, ref;\n      if (n < 2) {\n        // unoptimized, called only on small n\n        return 1;\n      }\n      f = 1;\n      for (i = o = 2, ref = n; (2 <= ref ? o <= ref : o >= ref); i = 2 <= ref ? ++o : --o) {\n        f *= i;\n      }\n      return f;\n    },\n    // ------------------------------------------------------------------------------\n    // search --- most guessable match sequence -------------------------------------\n    // ------------------------------------------------------------------------------\n\n    // takes a sequence of overlapping matches, returns the non-overlapping sequence with\n    // minimum guesses. the following is a O(l_max * (n + m)) dynamic programming algorithm\n    // for a length-n password with m candidate matches. l_max is the maximum optimal\n    // sequence length spanning each prefix of the password. In practice it rarely exceeds 5 and the\n    // search terminates rapidly.\n\n    // the optimal \"minimum guesses\" sequence is here defined to be the sequence that\n    // minimizes the following function:\n\n    //    g = l! * Product(m.guesses for m in sequence) + D^(l - 1)\n\n    // where l is the length of the sequence.\n\n    // the factorial term is the number of ways to order l patterns.\n\n    // the D^(l-1) term is another length penalty, roughly capturing the idea that an\n    // attacker will try lower-length sequences first before trying length-l sequences.\n\n    // for example, consider a sequence that is date-repeat-dictionary.\n    //  - an attacker would need to try other date-repeat-dictionary combinations,\n    //    hence the product term.\n    //  - an attacker would need to try repeat-date-dictionary, dictionary-repeat-date,\n    //    ..., hence the factorial term.\n    //  - an attacker would also likely try length-1 (dictionary) and length-2 (dictionary-date)\n    //    sequences before length-3. assuming at minimum D guesses per pattern type,\n    //    D^(l-1) approximates Sum(D^i for i in [1..l-1]\n\n    // ------------------------------------------------------------------------------\n    most_guessable_match_sequence: function(password, matches, _exclude_additive = false) {\n      var _, bruteforce_update, guesses, k, l, len, len1, len2, lst, m, make_bruteforce_match, matches_by_j, n, o, optimal, optimal_l, optimal_match_sequence, q, ref, ref1, u, unwind, update, w;\n      n = password.length;\n      // partition matches into sublists according to ending index j\n      matches_by_j = (function() {\n        var o, ref, results;\n        results = [];\n        for (_ = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); _ = 0 <= ref ? ++o : --o) {\n          results.push([]);\n        }\n        return results;\n      })();\n      for (o = 0, len = matches.length; o < len; o++) {\n        m = matches[o];\n        matches_by_j[m.j].push(m);\n      }\n  // small detail: for deterministic output, sort each sublist by i.\n      for (q = 0, len1 = matches_by_j.length; q < len1; q++) {\n        lst = matches_by_j[q];\n        lst.sort(function(m1, m2) {\n          return m1.i - m2.i;\n        });\n      }\n      optimal = {\n        // optimal.m[k][l] holds final match in the best length-l match sequence covering the\n        // password prefix up to k, inclusive.\n        // if there is no length-l sequence that scores better (fewer guesses) than\n        // a shorter match sequence spanning the same prefix, optimal.m[k][l] is undefined.\n        m: (function() {\n          var ref, results, u;\n          results = [];\n          for (_ = u = 0, ref = n; (0 <= ref ? u < ref : u > ref); _ = 0 <= ref ? ++u : --u) {\n            results.push({});\n          }\n          return results;\n        })(),\n        // same structure as optimal.m -- holds the product term Prod(m.guesses for m in sequence).\n        // optimal.pi allows for fast (non-looping) updates to the minimization function.\n        pi: (function() {\n          var ref, results, u;\n          results = [];\n          for (_ = u = 0, ref = n; (0 <= ref ? u < ref : u > ref); _ = 0 <= ref ? ++u : --u) {\n            results.push({});\n          }\n          return results;\n        })(),\n        // same structure as optimal.m -- holds the overall metric.\n        g: (function() {\n          var ref, results, u;\n          results = [];\n          for (_ = u = 0, ref = n; (0 <= ref ? u < ref : u > ref); _ = 0 <= ref ? ++u : --u) {\n            results.push({});\n          }\n          return results;\n        })()\n      };\n      // helper: considers whether a length-l sequence ending at match m is better (fewer guesses)\n      // than previously encountered sequences, updating state if so.\n      update = (m, l) => {\n        var competing_g, competing_l, g, k, pi, ref;\n        k = m.j;\n        pi = this.estimate_guesses(m, password);\n        if (l > 1) {\n          // we're considering a length-l sequence ending with match m:\n          // obtain the product term in the minimization function by multiplying m's guesses\n          // by the product of the length-(l-1) sequence ending just before m, at m.i - 1.\n          pi *= optimal.pi[m.i - 1][l - 1];\n        }\n        // calculate the minimization func\n        g = this.factorial(l) * pi;\n        if (!_exclude_additive) {\n          g += Math.pow(MIN_GUESSES_BEFORE_GROWING_SEQUENCE, l - 1);\n        }\n        ref = optimal.g[k];\n        // update state if new best.\n        // first see if any competing sequences covering this prefix, with l or fewer matches,\n        // fare better than this sequence. if so, skip it and return.\n        for (competing_l in ref) {\n          competing_g = ref[competing_l];\n          if (competing_l > l) {\n            continue;\n          }\n          if (competing_g <= g) {\n            return;\n          }\n        }\n        // this sequence might be part of the final optimal sequence.\n        optimal.g[k][l] = g;\n        optimal.m[k][l] = m;\n        return optimal.pi[k][l] = pi;\n      };\n      // helper: evaluate bruteforce matches ending at k.\n      bruteforce_update = (k) => {\n        var i, l, last_m, ref, results, u;\n        // see if a single bruteforce match spanning the k-prefix is optimal.\n        m = make_bruteforce_match(0, k);\n        update(m, 1);\n        results = [];\n        for (i = u = 1, ref = k; (1 <= ref ? u <= ref : u >= ref); i = 1 <= ref ? ++u : --u) {\n          // generate k bruteforce matches, spanning from (i=1, j=k) up to (i=k, j=k).\n          // see if adding these new matches to any of the sequences in optimal[i-1]\n          // leads to new bests.\n          m = make_bruteforce_match(i, k);\n          results.push((function() {\n            var ref1, results1;\n            ref1 = optimal.m[i - 1];\n            results1 = [];\n            for (l in ref1) {\n              last_m = ref1[l];\n              l = parseInt(l);\n              if (last_m.pattern === 'bruteforce') {\n                // corner: an optimal sequence will never have two adjacent bruteforce matches.\n                // it is strictly better to have a single bruteforce match spanning the same region:\n                // same contribution to the guess product with a lower length.\n                // --> safe to skip those cases.\n                continue;\n              }\n              // try adding m to this length-l sequence.\n              results1.push(update(m, l + 1));\n            }\n            return results1;\n          })());\n        }\n        return results;\n      };\n      // helper: make bruteforce match objects spanning i to j, inclusive.\n      make_bruteforce_match = (i, j) => {\n        return {\n          pattern: 'bruteforce',\n          token: password.slice(i, +j + 1 || 9e9),\n          i: i,\n          j: j\n        };\n      };\n      // helper: step backwards through optimal.m starting at the end,\n      // constructing the final optimal match sequence.\n      unwind = (n) => {\n        var candidate_g, candidate_l, g, k, l, optimal_match_sequence, ref;\n        optimal_match_sequence = [];\n        k = n - 1;\n        // find the final best sequence length and score\n        l = void 0;\n        g = 2e308;\n        ref = optimal.g[k];\n        for (candidate_l in ref) {\n          candidate_g = ref[candidate_l];\n          if (candidate_g < g) {\n            l = candidate_l;\n            g = candidate_g;\n          }\n        }\n        while (k >= 0) {\n          m = optimal.m[k][l];\n          optimal_match_sequence.unshift(m);\n          k = m.i - 1;\n          l--;\n        }\n        return optimal_match_sequence;\n      };\n      for (k = u = 0, ref = n; (0 <= ref ? u < ref : u > ref); k = 0 <= ref ? ++u : --u) {\n        ref1 = matches_by_j[k];\n        for (w = 0, len2 = ref1.length; w < len2; w++) {\n          m = ref1[w];\n          if (m.i > 0) {\n            for (l in optimal.m[m.i - 1]) {\n              l = parseInt(l);\n              update(m, l + 1);\n            }\n          } else {\n            update(m, 1);\n          }\n        }\n        bruteforce_update(k);\n      }\n      optimal_match_sequence = unwind(n);\n      optimal_l = optimal_match_sequence.length;\n      // corner: empty password\n      if (password.length === 0) {\n        guesses = 1;\n      } else {\n        guesses = optimal.g[n - 1][optimal_l];\n      }\n      return {\n        // final result object\n        password: password,\n        guesses: guesses,\n        guesses_log10: this.log10(guesses),\n        sequence: optimal_match_sequence\n      };\n    },\n    // ------------------------------------------------------------------------------\n    // guess estimation -- one function per match pattern ---------------------------\n    // ------------------------------------------------------------------------------\n    estimate_guesses: function(match, password) {\n      var estimation_functions, guesses, min_guesses;\n      if (match.guesses != null) {\n        return match.guesses; // a match's guess estimate doesn't change. cache it.\n      }\n      min_guesses = 1;\n      if (match.token.length < password.length) {\n        min_guesses = match.token.length === 1 ? MIN_SUBMATCH_GUESSES_SINGLE_CHAR : MIN_SUBMATCH_GUESSES_MULTI_CHAR;\n      }\n      estimation_functions = {\n        bruteforce: this.bruteforce_guesses,\n        dictionary: this.dictionary_guesses,\n        spatial: this.spatial_guesses,\n        repeat: this.repeat_guesses,\n        sequence: this.sequence_guesses,\n        regex: this.regex_guesses,\n        date: this.date_guesses\n      };\n      guesses = estimation_functions[match.pattern].call(this, match);\n      match.guesses = Math.max(guesses, min_guesses);\n      match.guesses_log10 = this.log10(match.guesses);\n      return match.guesses;\n    },\n    bruteforce_guesses: function(match) {\n      var guesses, min_guesses;\n      guesses = Math.pow(BRUTEFORCE_CARDINALITY, match.token.length);\n      if (guesses === Number.POSITIVE_INFINITY) {\n        guesses = Number.MAX_VALUE;\n      }\n      min_guesses = match.token.length === 1 ? MIN_SUBMATCH_GUESSES_SINGLE_CHAR + 1 : MIN_SUBMATCH_GUESSES_MULTI_CHAR + 1;\n      return Math.max(guesses, min_guesses);\n    },\n    repeat_guesses: function(match) {\n      return match.base_guesses * match.repeat_count;\n    },\n    sequence_guesses: function(match) {\n      var base_guesses, first_chr;\n      first_chr = match.token.charAt(0);\n      // lower guesses for obvious starting points\n      if (first_chr === 'a' || first_chr === 'A' || first_chr === 'z' || first_chr === 'Z' || first_chr === '0' || first_chr === '1' || first_chr === '9') {\n        base_guesses = 4;\n      } else {\n        if (first_chr.match(/\\d/)) {\n          base_guesses = 10; // digits\n        } else {\n          // could give a higher base for uppercase,\n          // assigning 26 to both upper and lower sequences is more conservative.\n          base_guesses = 26;\n        }\n      }\n      if (!match.ascending) {\n        // need to try a descending sequence in addition to every ascending sequence ->\n        // 2x guesses\n        base_guesses *= 2;\n      }\n      return base_guesses * match.token.length;\n    },\n    MIN_YEAR_SPACE: 20,\n    REFERENCE_YEAR: new Date().getFullYear(),\n    regex_guesses: function(match) {\n      var char_class_bases, year_space;\n      char_class_bases = {\n        alpha_lower: 26,\n        alpha_upper: 26,\n        alpha: 52,\n        alphanumeric: 62,\n        digits: 10,\n        symbols: 33\n      };\n      if (match.regex_name in char_class_bases) {\n        return Math.pow(char_class_bases[match.regex_name], match.token.length);\n      } else {\n        switch (match.regex_name) {\n          case 'recent_year':\n            // conservative estimate of year space: num years from REFERENCE_YEAR.\n            // if year is close to REFERENCE_YEAR, estimate a year space of MIN_YEAR_SPACE.\n            year_space = Math.abs(parseInt(match.regex_match[0]) - this.REFERENCE_YEAR);\n            year_space = Math.max(year_space, this.MIN_YEAR_SPACE);\n            return year_space;\n        }\n      }\n    },\n    date_guesses: function(match) {\n      var guesses, year_space;\n      // base guesses: (year distance from REFERENCE_YEAR) * num_days * num_years\n      year_space = Math.max(Math.abs(match.year - this.REFERENCE_YEAR), this.MIN_YEAR_SPACE);\n      guesses = year_space * 365;\n      if (match.separator) {\n        // add factor of 4 for separator selection (one of ~4 choices)\n        guesses *= 4;\n      }\n      return guesses;\n    },\n    KEYBOARD_AVERAGE_DEGREE: calc_average_degree(adjacency_graphs.qwerty),\n    // slightly different for keypad/mac keypad, but close enough\n    KEYPAD_AVERAGE_DEGREE: calc_average_degree(adjacency_graphs.keypad),\n    KEYBOARD_STARTING_POSITIONS: ((function() {\n      var ref, results;\n      ref = adjacency_graphs.qwerty;\n      results = [];\n      for (k in ref) {\n        v = ref[k];\n        results.push(k);\n      }\n      return results;\n    })()).length,\n    KEYPAD_STARTING_POSITIONS: ((function() {\n      var ref, results;\n      ref = adjacency_graphs.keypad;\n      results = [];\n      for (k in ref) {\n        v = ref[k];\n        results.push(k);\n      }\n      return results;\n    })()).length,\n    spatial_guesses: function(match) {\n      var L, S, U, d, guesses, i, j, o, possible_turns, q, ref, ref1, ref2, ref3, s, shifted_variations, t, u;\n      if ((ref = match.graph) === 'qwerty' || ref === 'dvorak') {\n        s = this.KEYBOARD_STARTING_POSITIONS;\n        d = this.KEYBOARD_AVERAGE_DEGREE;\n      } else {\n        s = this.KEYPAD_STARTING_POSITIONS;\n        d = this.KEYPAD_AVERAGE_DEGREE;\n      }\n      guesses = 0;\n      L = match.token.length;\n      t = match.turns;\n  // estimate the number of possible patterns w/ length L or less with t turns or less.\n      for (i = o = 2, ref1 = L; (2 <= ref1 ? o <= ref1 : o >= ref1); i = 2 <= ref1 ? ++o : --o) {\n        possible_turns = Math.min(t, i - 1);\n        for (j = q = 1, ref2 = possible_turns; (1 <= ref2 ? q <= ref2 : q >= ref2); j = 1 <= ref2 ? ++q : --q) {\n          guesses += this.nCk(i - 1, j - 1) * s * Math.pow(d, j);\n        }\n      }\n      // add extra guesses for shifted keys. (% instead of 5, A instead of a.)\n      // math is similar to extra guesses of l33t substitutions in dictionary matches.\n      if (match.shifted_count) {\n        S = match.shifted_count;\n        U = match.token.length - match.shifted_count; // unshifted count\n        if (S === 0 || U === 0) {\n          guesses *= 2;\n        } else {\n          shifted_variations = 0;\n          for (i = u = 1, ref3 = Math.min(S, U); (1 <= ref3 ? u <= ref3 : u >= ref3); i = 1 <= ref3 ? ++u : --u) {\n            shifted_variations += this.nCk(S + U, i);\n          }\n          guesses *= shifted_variations;\n        }\n      }\n      return guesses;\n    },\n    dictionary_guesses: function(match) {\n      var reversed_variations;\n      match.base_guesses = match.rank; // keep these as properties for display purposes\n      match.uppercase_variations = this.uppercase_variations(match);\n      match.l33t_variations = this.l33t_variations(match);\n      reversed_variations = match.reversed && 2 || 1;\n      return match.base_guesses * match.uppercase_variations * match.l33t_variations * reversed_variations;\n    },\n    START_UPPER: /^[A-Z][^A-Z]+$/,\n    END_UPPER: /^[^A-Z]+[A-Z]$/,\n    ALL_UPPER: /^[^a-z]+$/,\n    ALL_LOWER: /^[^A-Z]+$/,\n    uppercase_variations: function(match) {\n      var L, U, chr, i, len, o, q, ref, ref1, regex, variations, word;\n      word = match.token;\n      if (word.match(this.ALL_LOWER) || word.toLowerCase() === word) {\n        return 1;\n      }\n      ref = [this.START_UPPER, this.END_UPPER, this.ALL_UPPER];\n      // a capitalized word is the most common capitalization scheme,\n      // so it only doubles the search space (uncapitalized + capitalized).\n      // allcaps and end-capitalized are common enough too, underestimate as 2x factor to be safe.\n      for (o = 0, len = ref.length; o < len; o++) {\n        regex = ref[o];\n        if (word.match(regex)) {\n          return 2;\n        }\n      }\n      // otherwise calculate the number of ways to capitalize U+L uppercase+lowercase letters\n      // with U uppercase letters or less. or, if there's more uppercase than lower (for eg. PASSwORD),\n      // the number of ways to lowercase U+L letters with L lowercase letters or less.\n      U = ((function() {\n        var len1, q, ref1, results;\n        ref1 = word.split('');\n        results = [];\n        for (q = 0, len1 = ref1.length; q < len1; q++) {\n          chr = ref1[q];\n          if (chr.match(/[A-Z]/)) {\n            results.push(chr);\n          }\n        }\n        return results;\n      })()).length;\n      L = ((function() {\n        var len1, q, ref1, results;\n        ref1 = word.split('');\n        results = [];\n        for (q = 0, len1 = ref1.length; q < len1; q++) {\n          chr = ref1[q];\n          if (chr.match(/[a-z]/)) {\n            results.push(chr);\n          }\n        }\n        return results;\n      })()).length;\n      variations = 0;\n      for (i = q = 1, ref1 = Math.min(U, L); (1 <= ref1 ? q <= ref1 : q >= ref1); i = 1 <= ref1 ? ++q : --q) {\n        variations += this.nCk(U + L, i);\n      }\n      return variations;\n    },\n    l33t_variations: function(match) {\n      var S, U, chr, chrs, i, o, p, possibilities, ref, ref1, subbed, unsubbed, variations;\n      if (!match.l33t) {\n        return 1;\n      }\n      variations = 1;\n      ref = match.sub;\n      for (subbed in ref) {\n        unsubbed = ref[subbed];\n        // lower-case match.token before calculating: capitalization shouldn't affect l33t calc.\n        chrs = match.token.toLowerCase().split('');\n        S = ((function() {\n          var len, o, results;\n          results = [];\n          for (o = 0, len = chrs.length; o < len; o++) {\n            chr = chrs[o];\n            if (chr === subbed) {\n              results.push(chr);\n            }\n          }\n          return results;\n        })()).length; // num of subbed chars\n        U = ((function() {\n          var len, o, results;\n          results = [];\n          for (o = 0, len = chrs.length; o < len; o++) {\n            chr = chrs[o];\n            if (chr === unsubbed) {\n              results.push(chr);\n            }\n          }\n          return results;\n        })()).length; // num of unsubbed chars\n        if (S === 0 || U === 0) {\n          // for this sub, password is either fully subbed (444) or fully unsubbed (aaa)\n          // treat that as doubling the space (attacker needs to try fully subbed chars in addition to\n          // unsubbed.)\n          variations *= 2;\n        } else {\n          // this case is similar to capitalization:\n          // with aa44a, U = 3, S = 2, attacker needs to try unsubbed + one sub + two subs\n          p = Math.min(U, S);\n          possibilities = 0;\n          for (i = o = 1, ref1 = p; (1 <= ref1 ? o <= ref1 : o >= ref1); i = 1 <= ref1 ? ++o : --o) {\n            possibilities += this.nCk(U + S, i);\n          }\n          variations *= possibilities;\n        }\n      }\n      return variations;\n    }\n  };\n\n  // utilities --------------------------------------------------------------------\n  return scoring;\n\n});\n"]}