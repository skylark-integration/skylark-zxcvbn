{"version":3,"sources":["matching.js"],"names":["define","adjacency_graphs","frequency_lists","scoring","DATE_SPLITS","GRAPHS","L33T_TABLE","RANKED_DICTIONARIES","REGEXEN","build_ranked_dict","lst","name","ordered_list","i","len1","o","result","length","qwerty","dvorak","keypad","mac_keypad","a","b","c","e","g","l","s","t","x","z","recent_year","4","5","6","7","8","empty","obj","k","results","push","extend","lst2","apply","translate","string","chr_map","chr","ref","split","join","mod","n","m","sorted","matches","sort","m1","m2","j","omnimatch","password","matcher","matchers","this","dictionary_match","reverse_dictionary_match","l33t_match","spatial_match","repeat_match","sequence_match","regex_match","date_match","call","_ranked_dictionaries","dictionary_name","len","p","password_lower","rank","ranked_dict","ref1","ref2","word","toLowerCase","slice","pattern","token","matched_word","reversed","l33t","match","reversed_password","reverse","set_user_input_dictionary","relevant_l33t_subtable","table","letter","password_chars","relevant_subs","sub","subs","subtable","len2","enumerate_l33t_subs","dedup","helper","keys","l33t_chr","sub_dict","sub_dicts","assoc","deduped","label","members","v","dup_l33t_index","first_key","next_subs","q","rest_keys","sub_alternative","sub_extension","concat","splice","_l33t_table","match_sub","subbed_chr","subbed_password","indexOf","sub_display","filter","_graphs","graph","graph_name","spatial_match_helper","SHIFTED_RX","adj","adjacents","cur_char","cur_direction","found","found_direction","last_direction","shifted_count","turns","exec","charAt","base_analysis","base_guesses","base_matches","base_token","greedy","greedy_match","lastIndex","lazy","lazy_anchored","lazy_match","index","most_guessable_match_sequence","sequence","guesses","repeat_count","MAX_DELTA","delta","last_delta","update","sequence_name","sequence_space","Math","abs","test","ascending","charCodeAt","_regexen","regex","rx_match","regex_name","best_candidate","candidate","candidates","distance","dmy","maybe_date_no_separator","maybe_date_with_separator","metric","min_distance","r","ref3","ref4","ref5","ref6","ref7","map_ints_to_dmy","parseInt","year","REFERENCE_YEAR","separator","month","day","is_submatch","len3","other_match","u","ints","dm","int","over_12","over_31","possible_year_splits","rest","under_1","y","map_ints_to_dm","two_to_four_digit_year","d"],"mappings":"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","file":"../matching.js","sourcesContent":["define([\n  './adjacency_graphs',\n  './frequency_lists',\n  './scoring'\n],function(adjacency_graphs,frequency_lists,scoring){\n  var DATE_MAX_YEAR, DATE_MIN_YEAR, DATE_SPLITS, GRAPHS, L33T_TABLE, RANKED_DICTIONARIES, REGEXEN, adjacency_graphs, build_ranked_dict, frequency_lists, lst, matching, name, scoring;\n\n  build_ranked_dict = function(ordered_list) {\n    var i, len1, o, result, word;\n    result = {};\n    i = 1; // rank starts at 1, not 0\n    for (o = 0, len1 = ordered_list.length; o < len1; o++) {\n      word = ordered_list[o];\n      result[word] = i;\n      i += 1;\n    }\n    return result;\n  };\n\n  RANKED_DICTIONARIES = {};\n\n  for (name in frequency_lists) {\n    lst = frequency_lists[name];\n    RANKED_DICTIONARIES[name] = build_ranked_dict(lst);\n  }\n\n  GRAPHS = {\n    qwerty: adjacency_graphs.qwerty,\n    dvorak: adjacency_graphs.dvorak,\n    keypad: adjacency_graphs.keypad,\n    mac_keypad: adjacency_graphs.mac_keypad\n  };\n\n  L33T_TABLE = {\n    a: ['4', '@'],\n    b: ['8'],\n    c: ['(', '{', '[', '<'],\n    e: ['3'],\n    g: ['6', '9'],\n    i: ['1', '!', '|'],\n    l: ['1', '|', '7'],\n    o: ['0'],\n    s: ['$', '5'],\n    t: ['+', '7'],\n    x: ['%'],\n    z: ['2']\n  };\n\n  REGEXEN = {\n    recent_year: /19\\d\\d|200\\d|201\\d/g\n  };\n\n  DATE_MAX_YEAR = 2050;\n\n  DATE_MIN_YEAR = 1000;\n\n  DATE_SPLITS = {\n    4: [\n      [\n        1,\n        2 // 1 1 91 (2nd split starts at index 1, 3rd at index 2)\n      ],\n      [\n        2,\n        3 // 91 1 1\n      ]\n    ],\n    5: [\n      [\n        1,\n        3 // 1 11 91\n      ],\n      [\n        2,\n        3 // 11 1 91\n      ]\n    ],\n    6: [\n      [\n        1,\n        2 // 1 1 1991\n      ],\n      [\n        2,\n        4 // 11 11 91\n      ],\n      [\n        4,\n        5 // 1991 1 1\n      ]\n    ],\n    7: [\n      [\n        1,\n        3 // 1 11 1991\n      ],\n      [\n        2,\n        3 // 11 1 1991\n      ],\n      [\n        4,\n        5 // 1991 1 11\n      ],\n      [\n        4,\n        6 // 1991 11 1\n      ]\n    ],\n    8: [\n      [\n        2,\n        4 // 11 11 1991\n      ],\n      [\n        4,\n        6 // 1991 11 11\n      ]\n    ]\n  };\n\n  matching = {\n    empty: function(obj) {\n      var k;\n      return ((function() {\n        var results;\n        results = [];\n        for (k in obj) {\n          results.push(k);\n        }\n        return results;\n      })()).length === 0;\n    },\n    extend: function(lst, lst2) {\n      return lst.push.apply(lst, lst2);\n    },\n    translate: function(string, chr_map) {\n      var chr;\n      return ((function() {\n        var len1, o, ref, results;\n        ref = string.split('');\n        results = [];\n        for (o = 0, len1 = ref.length; o < len1; o++) {\n          chr = ref[o];\n          results.push(chr_map[chr] || chr);\n        }\n        return results;\n      })()).join('');\n    },\n    mod: function(n, m) {\n      return ((n % m) + m) % m; // mod impl that works for negative numbers\n    },\n    sorted: function(matches) {\n      // sort on i primary, j secondary\n      return matches.sort(function(m1, m2) {\n        return (m1.i - m2.i) || (m1.j - m2.j);\n      });\n    },\n    // ------------------------------------------------------------------------------\n    // omnimatch -- combine everything ----------------------------------------------\n    // ------------------------------------------------------------------------------\n    omnimatch: function(password) {\n      var len1, matcher, matchers, matches, o;\n      matches = [];\n      matchers = [this.dictionary_match, this.reverse_dictionary_match, this.l33t_match, this.spatial_match, this.repeat_match, this.sequence_match, this.regex_match, this.date_match];\n      for (o = 0, len1 = matchers.length; o < len1; o++) {\n        matcher = matchers[o];\n        this.extend(matches, matcher.call(this, password));\n      }\n      return this.sorted(matches);\n    },\n    //-------------------------------------------------------------------------------\n    // dictionary match (common passwords, english, last names, etc) ----------------\n    //-------------------------------------------------------------------------------\n    dictionary_match: function(password, _ranked_dictionaries = RANKED_DICTIONARIES) {\n      var dictionary_name, i, j, len, matches, o, p, password_lower, rank, ranked_dict, ref, ref1, ref2, word;\n      // _ranked_dictionaries variable is for unit testing purposes\n      matches = [];\n      len = password.length;\n      password_lower = password.toLowerCase();\n      for (dictionary_name in _ranked_dictionaries) {\n        ranked_dict = _ranked_dictionaries[dictionary_name];\n        for (i = o = 0, ref = len; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n          for (j = p = ref1 = i, ref2 = len; (ref1 <= ref2 ? p < ref2 : p > ref2); j = ref1 <= ref2 ? ++p : --p) {\n            if (password_lower.slice(i, +j + 1 || 9e9) in ranked_dict) {\n              word = password_lower.slice(i, +j + 1 || 9e9);\n              rank = ranked_dict[word];\n              matches.push({\n                pattern: 'dictionary',\n                i: i,\n                j: j,\n                token: password.slice(i, +j + 1 || 9e9),\n                matched_word: word,\n                rank: rank,\n                dictionary_name: dictionary_name,\n                reversed: false,\n                l33t: false\n              });\n            }\n          }\n        }\n      }\n      return this.sorted(matches);\n    },\n    reverse_dictionary_match: function(password, _ranked_dictionaries = RANKED_DICTIONARIES) {\n      var len1, match, matches, o, reversed_password;\n      reversed_password = password.split('').reverse().join('');\n      matches = this.dictionary_match(reversed_password, _ranked_dictionaries);\n      for (o = 0, len1 = matches.length; o < len1; o++) {\n        match = matches[o];\n        match.token = match.token.split('').reverse().join(''); // reverse back\n        match.reversed = true;\n        // map coordinates back to original string\n        [match.i, match.j] = [password.length - 1 - match.j, password.length - 1 - match.i];\n      }\n      return this.sorted(matches);\n    },\n    set_user_input_dictionary: function(ordered_list) {\n      return RANKED_DICTIONARIES['user_inputs'] = build_ranked_dict(ordered_list.slice());\n    },\n    //-------------------------------------------------------------------------------\n    // dictionary match with common l33t substitutions ------------------------------\n    //-------------------------------------------------------------------------------\n\n    // makes a pruned copy of l33t_table that only includes password's possible substitutions\n    relevant_l33t_subtable: function(password, table) {\n      var chr, len1, letter, o, password_chars, ref, relevant_subs, sub, subs, subtable;\n      password_chars = {};\n      ref = password.split('');\n      for (o = 0, len1 = ref.length; o < len1; o++) {\n        chr = ref[o];\n        password_chars[chr] = true;\n      }\n      subtable = {};\n      for (letter in table) {\n        subs = table[letter];\n        relevant_subs = (function() {\n          var len2, p, results;\n          results = [];\n          for (p = 0, len2 = subs.length; p < len2; p++) {\n            sub = subs[p];\n            if (sub in password_chars) {\n              results.push(sub);\n            }\n          }\n          return results;\n        })();\n        if (relevant_subs.length > 0) {\n          subtable[letter] = relevant_subs;\n        }\n      }\n      return subtable;\n    },\n    // returns the list of possible 1337 replacement dictionaries for a given password\n    enumerate_l33t_subs: function(table) {\n      var chr, dedup, helper, k, keys, l33t_chr, len1, len2, o, p, sub, sub_dict, sub_dicts, subs;\n      keys = (function() {\n        var results;\n        results = [];\n        for (k in table) {\n          results.push(k);\n        }\n        return results;\n      })();\n      subs = [[]];\n      dedup = function(subs) {\n        var assoc, deduped, label, len1, members, o, sub, v;\n        deduped = [];\n        members = {};\n        for (o = 0, len1 = subs.length; o < len1; o++) {\n          sub = subs[o];\n          assoc = (function() {\n            var len2, p, results;\n            results = [];\n            for (v = p = 0, len2 = sub.length; p < len2; v = ++p) {\n              k = sub[v];\n              results.push([k, v]);\n            }\n            return results;\n          })();\n          assoc.sort();\n          label = ((function() {\n            var len2, p, results;\n            results = [];\n            for (v = p = 0, len2 = assoc.length; p < len2; v = ++p) {\n              k = assoc[v];\n              results.push(k + ',' + v);\n            }\n            return results;\n          })()).join('-');\n          if (!(label in members)) {\n            members[label] = true;\n            deduped.push(sub);\n          }\n        }\n        return deduped;\n      };\n      helper = function(keys) {\n        var dup_l33t_index, first_key, i, l33t_chr, len1, len2, next_subs, o, p, q, ref, ref1, rest_keys, sub, sub_alternative, sub_extension;\n        if (!keys.length) {\n          return;\n        }\n        first_key = keys[0];\n        rest_keys = keys.slice(1);\n        next_subs = [];\n        ref = table[first_key];\n        for (o = 0, len1 = ref.length; o < len1; o++) {\n          l33t_chr = ref[o];\n          for (p = 0, len2 = subs.length; p < len2; p++) {\n            sub = subs[p];\n            dup_l33t_index = -1;\n            for (i = q = 0, ref1 = sub.length; (0 <= ref1 ? q < ref1 : q > ref1); i = 0 <= ref1 ? ++q : --q) {\n              if (sub[i][0] === l33t_chr) {\n                dup_l33t_index = i;\n                break;\n              }\n            }\n            if (dup_l33t_index === -1) {\n              sub_extension = sub.concat([[l33t_chr, first_key]]);\n              next_subs.push(sub_extension);\n            } else {\n              sub_alternative = sub.slice(0);\n              sub_alternative.splice(dup_l33t_index, 1);\n              sub_alternative.push([l33t_chr, first_key]);\n              next_subs.push(sub);\n              next_subs.push(sub_alternative);\n            }\n          }\n        }\n        subs = dedup(next_subs);\n        return helper(rest_keys);\n      };\n      helper(keys);\n      sub_dicts = []; // convert from assoc lists to dicts\n      for (o = 0, len1 = subs.length; o < len1; o++) {\n        sub = subs[o];\n        sub_dict = {};\n        for (p = 0, len2 = sub.length; p < len2; p++) {\n          [l33t_chr, chr] = sub[p];\n          sub_dict[l33t_chr] = chr;\n        }\n        sub_dicts.push(sub_dict);\n      }\n      return sub_dicts;\n    },\n    l33t_match: function(password, _ranked_dictionaries = RANKED_DICTIONARIES, _l33t_table = L33T_TABLE) {\n      var chr, k, len1, len2, match, match_sub, matches, o, p, ref, ref1, sub, subbed_chr, subbed_password, token, v;\n      matches = [];\n      ref = this.enumerate_l33t_subs(this.relevant_l33t_subtable(password, _l33t_table));\n      for (o = 0, len1 = ref.length; o < len1; o++) {\n        sub = ref[o];\n        if (this.empty(sub)) { // corner case: password has no relevant subs.\n          break;\n        }\n        subbed_password = this.translate(password, sub);\n        ref1 = this.dictionary_match(subbed_password, _ranked_dictionaries);\n        for (p = 0, len2 = ref1.length; p < len2; p++) {\n          match = ref1[p];\n          token = password.slice(match.i, +match.j + 1 || 9e9);\n          if (token.toLowerCase() === match.matched_word) {\n            continue; // only return the matches that contain an actual substitution\n          }\n          match_sub = {}; // subset of mappings in sub that are in use for this match\n          for (subbed_chr in sub) {\n            chr = sub[subbed_chr];\n            if (token.indexOf(subbed_chr) !== -1) {\n              match_sub[subbed_chr] = chr;\n            }\n          }\n          match.l33t = true;\n          match.token = token;\n          match.sub = match_sub;\n          match.sub_display = ((function() {\n            var results;\n            results = [];\n            for (k in match_sub) {\n              v = match_sub[k];\n              results.push(`${k} -> ${v}`);\n            }\n            return results;\n          })()).join(', ');\n          matches.push(match);\n        }\n      }\n      return this.sorted(matches.filter(function(match) {\n        // filter single-character l33t matches to reduce noise.\n        // otherwise '1' matches 'i', '4' matches 'a', both very common English words\n        // with low dictionary rank.\n        return match.token.length > 1;\n      }));\n    },\n    // ------------------------------------------------------------------------------\n    // spatial match (qwerty/dvorak/keypad) -----------------------------------------\n    // ------------------------------------------------------------------------------\n    spatial_match: function(password, _graphs = GRAPHS) {\n      var graph, graph_name, matches;\n      matches = [];\n      for (graph_name in _graphs) {\n        graph = _graphs[graph_name];\n        this.extend(matches, this.spatial_match_helper(password, graph, graph_name));\n      }\n      return this.sorted(matches);\n    },\n    SHIFTED_RX: /[~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?]/,\n    spatial_match_helper: function(password, graph, graph_name) {\n      var adj, adjacents, cur_char, cur_direction, found, found_direction, i, j, last_direction, len1, matches, o, prev_char, shifted_count, turns;\n      matches = [];\n      i = 0;\n      while (i < password.length - 1) {\n        j = i + 1;\n        last_direction = null;\n        turns = 0;\n        if ((graph_name === 'qwerty' || graph_name === 'dvorak') && this.SHIFTED_RX.exec(password.charAt(i))) {\n          // initial character is shifted\n          shifted_count = 1;\n        } else {\n          shifted_count = 0;\n        }\n        while (true) {\n          prev_char = password.charAt(j - 1);\n          found = false;\n          found_direction = -1;\n          cur_direction = -1;\n          adjacents = graph[prev_char] || [];\n          // consider growing pattern by one character if j hasn't gone over the edge.\n          if (j < password.length) {\n            cur_char = password.charAt(j);\n            for (o = 0, len1 = adjacents.length; o < len1; o++) {\n              adj = adjacents[o];\n              cur_direction += 1;\n              if (adj && adj.indexOf(cur_char) !== -1) {\n                found = true;\n                found_direction = cur_direction;\n                if (adj.indexOf(cur_char) === 1) {\n                  // index 1 in the adjacency means the key is shifted,\n                  // 0 means unshifted: A vs a, % vs 5, etc.\n                  // for example, 'q' is adjacent to the entry '2@'.\n                  // @ is shifted w/ index 1, 2 is unshifted.\n                  shifted_count += 1;\n                }\n                if (last_direction !== found_direction) {\n                  // adding a turn is correct even in the initial case when last_direction is null:\n                  // every spatial pattern starts with a turn.\n                  turns += 1;\n                  last_direction = found_direction;\n                }\n                break;\n              }\n            }\n          }\n          // if the current pattern continued, extend j and try to grow again\n          if (found) {\n            j += 1;\n          } else {\n            // otherwise push the pattern discovered so far, if any...\n            if (j - i > 2) { // don't consider length 1 or 2 chains.\n              matches.push({\n                pattern: 'spatial',\n                i: i,\n                j: j - 1,\n                token: password.slice(i, j),\n                graph: graph_name,\n                turns: turns,\n                shifted_count: shifted_count\n              });\n            }\n            // ...and then start a new search for the rest of the password.\n            i = j;\n            break;\n          }\n        }\n      }\n      return matches;\n    },\n    //-------------------------------------------------------------------------------\n    // repeats (aaa, abcabcabc) and sequences (abcdef) ------------------------------\n    //-------------------------------------------------------------------------------\n    repeat_match: function(password) {\n      var base_analysis, base_guesses, base_matches, base_token, greedy, greedy_match, i, j, lastIndex, lazy, lazy_anchored, lazy_match, match, matches;\n      matches = [];\n      greedy = /(.+)\\1+/g;\n      lazy = /(.+?)\\1+/g;\n      lazy_anchored = /^(.+?)\\1+$/;\n      lastIndex = 0;\n      while (lastIndex < password.length) {\n        greedy.lastIndex = lazy.lastIndex = lastIndex;\n        greedy_match = greedy.exec(password);\n        lazy_match = lazy.exec(password);\n        if (greedy_match == null) {\n          break;\n        }\n        if (greedy_match[0].length > lazy_match[0].length) {\n          // greedy beats lazy for 'aabaab'\n          //   greedy: [aabaab, aab]\n          //   lazy:   [aa,     a]\n          match = greedy_match;\n          // greedy's repeated string might itself be repeated, eg.\n          // aabaab in aabaabaabaab.\n          // run an anchored lazy match on greedy's repeated string\n          // to find the shortest repeated string\n          base_token = lazy_anchored.exec(match[0])[1];\n        } else {\n          // lazy beats greedy for 'aaaaa'\n          //   greedy: [aaaa,  aa]\n          //   lazy:   [aaaaa, a]\n          match = lazy_match;\n          base_token = match[1];\n        }\n        [i, j] = [match.index, match.index + match[0].length - 1];\n        // recursively match and score the base string\n        base_analysis = scoring.most_guessable_match_sequence(base_token, this.omnimatch(base_token));\n        base_matches = base_analysis.sequence;\n        base_guesses = base_analysis.guesses;\n        matches.push({\n          pattern: 'repeat',\n          i: i,\n          j: j,\n          token: match[0],\n          base_token: base_token,\n          base_guesses: base_guesses,\n          base_matches: base_matches,\n          repeat_count: match[0].length / base_token.length\n        });\n        lastIndex = j + 1;\n      }\n      return matches;\n    },\n    MAX_DELTA: 5,\n    sequence_match: function(password) {\n      var delta, i, j, k, last_delta, o, ref, result, update;\n      // Identifies sequences by looking for repeated differences in unicode codepoint.\n      // this allows skipping, such as 9753, and also matches some extended unicode sequences\n      // such as Greek and Cyrillic alphabets.\n\n      // for example, consider the input 'abcdb975zy'\n\n      // password: a   b   c   d   b    9   7   5   z   y\n      // index:    0   1   2   3   4    5   6   7   8   9\n      // delta:      1   1   1  -2  -41  -2  -2  69   1\n\n      // expected result:\n      // [(i, j, delta), ...] = [(0, 3, 1), (5, 7, -2), (8, 9, 1)]\n      if (password.length === 1) {\n        return [];\n      }\n      update = (i, j, delta) => {\n        var ref, sequence_name, sequence_space, token;\n        if (j - i > 1 || Math.abs(delta) === 1) {\n          if ((0 < (ref = Math.abs(delta)) && ref <= this.MAX_DELTA)) {\n            token = password.slice(i, +j + 1 || 9e9);\n            if (/^[a-z]+$/.test(token)) {\n              sequence_name = 'lower';\n              sequence_space = 26;\n            } else if (/^[A-Z]+$/.test(token)) {\n              sequence_name = 'upper';\n              sequence_space = 26;\n            } else if (/^\\d+$/.test(token)) {\n              sequence_name = 'digits';\n              sequence_space = 10;\n            } else {\n              // conservatively stick with roman alphabet size.\n              // (this could be improved)\n              sequence_name = 'unicode';\n              sequence_space = 26;\n            }\n            return result.push({\n              pattern: 'sequence',\n              i: i,\n              j: j,\n              token: password.slice(i, +j + 1 || 9e9),\n              sequence_name: sequence_name,\n              sequence_space: sequence_space,\n              ascending: delta > 0\n            });\n          }\n        }\n      };\n      result = [];\n      i = 0;\n      last_delta = null;\n      for (k = o = 1, ref = password.length; (1 <= ref ? o < ref : o > ref); k = 1 <= ref ? ++o : --o) {\n        delta = password.charCodeAt(k) - password.charCodeAt(k - 1);\n        if (last_delta == null) {\n          last_delta = delta;\n        }\n        if (delta === last_delta) {\n          continue;\n        }\n        j = k - 1;\n        update(i, j, last_delta);\n        i = j;\n        last_delta = delta;\n      }\n      update(i, password.length - 1, last_delta);\n      return result;\n    },\n    //-------------------------------------------------------------------------------\n    // regex matching ---------------------------------------------------------------\n    //-------------------------------------------------------------------------------\n    regex_match: function(password, _regexen = REGEXEN) {\n      var matches, regex, rx_match, token;\n      matches = [];\n      for (name in _regexen) {\n        regex = _regexen[name];\n        regex.lastIndex = 0; // keeps regex_match stateless\n        while (rx_match = regex.exec(password)) {\n          token = rx_match[0];\n          matches.push({\n            pattern: 'regex',\n            token: token,\n            i: rx_match.index,\n            j: rx_match.index + rx_match[0].length - 1,\n            regex_name: name,\n            regex_match: rx_match\n          });\n        }\n      }\n      return this.sorted(matches);\n    },\n    //-------------------------------------------------------------------------------\n    // date matching ----------------------------------------------------------------\n    //-------------------------------------------------------------------------------\n    date_match: function(password) {\n      var best_candidate, candidate, candidates, distance, dmy, i, j, k, l, len1, len2, matches, maybe_date_no_separator, maybe_date_with_separator, metric, min_distance, o, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, rx_match, s, t, token;\n      // a \"date\" is recognized as:\n      //   any 3-tuple that starts or ends with a 2- or 4-digit year,\n      //   with 2 or 0 separator chars (1.1.91 or 1191),\n      //   maybe zero-padded (01-01-91 vs 1-1-91),\n      //   a month between 1 and 12,\n      //   a day between 1 and 31.\n\n      // note: this isn't true date parsing in that \"feb 31st\" is allowed,\n      // this doesn't check for leap years, etc.\n\n      // recipe:\n      // start with regex to find maybe-dates, then attempt to map the integers\n      // onto month-day-year to filter the maybe-dates into dates.\n      // finally, remove matches that are substrings of other matches to reduce noise.\n\n      // note: instead of using a lazy or greedy regex to find many dates over the full string,\n      // this uses a ^...$ regex against every substring of the password -- less performant but leads\n      // to every possible date match.\n      matches = [];\n      maybe_date_no_separator = /^\\d{4,8}$/;\n      maybe_date_with_separator = /^(\\d{1,4})([\\s\\/\\\\_.-])(\\d{1,2})\\2(\\d{1,4})$/; // day, month, year\n      // separator\n      // day, month\n      // same separator\n      // day, month, year\n      // dates without separators are between length 4 '1191' and 8 '11111991'\n      for (i = o = 0, ref = password.length - 4; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {\n        for (j = p = ref1 = i + 3, ref2 = i + 7; (ref1 <= ref2 ? p <= ref2 : p >= ref2); j = ref1 <= ref2 ? ++p : --p) {\n          if (j >= password.length) {\n            break;\n          }\n          token = password.slice(i, +j + 1 || 9e9);\n          if (!maybe_date_no_separator.exec(token)) {\n            continue;\n          }\n          candidates = [];\n          ref3 = DATE_SPLITS[token.length];\n          for (q = 0, len1 = ref3.length; q < len1; q++) {\n            [k, l] = ref3[q];\n            dmy = this.map_ints_to_dmy([parseInt(token.slice(0, k)), parseInt(token.slice(k, l)), parseInt(token.slice(l))]);\n            if (dmy != null) {\n              candidates.push(dmy);\n            }\n          }\n          if (!(candidates.length > 0)) {\n            continue;\n          }\n          // at this point: different possible dmy mappings for the same i,j substring.\n          // match the candidate date that likely takes the fewest guesses: a year closest to 2000.\n          // (scoring.REFERENCE_YEAR).\n\n          // ie, considering '111504', prefer 11-15-04 to 1-1-1504\n          // (interpreting '04' as 2004)\n          best_candidate = candidates[0];\n          metric = function(candidate) {\n            return Math.abs(candidate.year - scoring.REFERENCE_YEAR);\n          };\n          min_distance = metric(candidates[0]);\n          ref4 = candidates.slice(1);\n          for (r = 0, len2 = ref4.length; r < len2; r++) {\n            candidate = ref4[r];\n            distance = metric(candidate);\n            if (distance < min_distance) {\n              [best_candidate, min_distance] = [candidate, distance];\n            }\n          }\n          matches.push({\n            pattern: 'date',\n            token: token,\n            i: i,\n            j: j,\n            separator: '',\n            year: best_candidate.year,\n            month: best_candidate.month,\n            day: best_candidate.day\n          });\n        }\n      }\n  // dates with separators are between length 6 '1/1/91' and 10 '11/11/1991'\n      for (i = s = 0, ref5 = password.length - 6; (0 <= ref5 ? s <= ref5 : s >= ref5); i = 0 <= ref5 ? ++s : --s) {\n        for (j = t = ref6 = i + 5, ref7 = i + 9; (ref6 <= ref7 ? t <= ref7 : t >= ref7); j = ref6 <= ref7 ? ++t : --t) {\n          if (j >= password.length) {\n            break;\n          }\n          token = password.slice(i, +j + 1 || 9e9);\n          rx_match = maybe_date_with_separator.exec(token);\n          if (rx_match == null) {\n            continue;\n          }\n          dmy = this.map_ints_to_dmy([parseInt(rx_match[1]), parseInt(rx_match[3]), parseInt(rx_match[4])]);\n          if (dmy == null) {\n            continue;\n          }\n          matches.push({\n            pattern: 'date',\n            token: token,\n            i: i,\n            j: j,\n            separator: rx_match[2],\n            year: dmy.year,\n            month: dmy.month,\n            day: dmy.day\n          });\n        }\n      }\n      // matches now contains all valid date strings in a way that is tricky to capture\n      // with regexes only. while thorough, it will contain some unintuitive noise:\n\n      // '2015_06_04', in addition to matching 2015_06_04, will also contain\n      // 5(!) other date matches: 15_06_04, 5_06_04, ..., even 2015 (matched as 5/1/2020)\n\n      // to reduce noise, remove date matches that are strict substrings of others\n      return this.sorted(matches.filter(function(match) {\n        var is_submatch, len3, other_match, u;\n        is_submatch = false;\n        for (u = 0, len3 = matches.length; u < len3; u++) {\n          other_match = matches[u];\n          if (match === other_match) {\n            continue;\n          }\n          if (other_match.i <= match.i && other_match.j >= match.j) {\n            is_submatch = true;\n            break;\n          }\n        }\n        return !is_submatch;\n      }));\n    },\n    map_ints_to_dmy: function(ints) {\n      var dm, int, len1, len2, len3, o, over_12, over_31, p, possible_year_splits, q, rest, under_1, y;\n      // given a 3-tuple, discard if:\n      //   middle int is over 31 (for all dmy formats, years are never allowed in the middle)\n      //   middle int is zero\n      //   any int is over the max allowable year\n      //   any int is over two digits but under the min allowable year\n      //   2 ints are over 31, the max allowable day\n      //   2 ints are zero\n      //   all ints are over 12, the max allowable month\n      if (ints[1] > 31 || ints[1] <= 0) {\n        return;\n      }\n      over_12 = 0;\n      over_31 = 0;\n      under_1 = 0;\n      for (o = 0, len1 = ints.length; o < len1; o++) {\n        int = ints[o];\n        if ((99 < int && int < DATE_MIN_YEAR) || int > DATE_MAX_YEAR) {\n          return;\n        }\n        if (int > 31) {\n          over_31 += 1;\n        }\n        if (int > 12) {\n          over_12 += 1;\n        }\n        if (int <= 0) {\n          under_1 += 1;\n        }\n      }\n      if (over_31 >= 2 || over_12 === 3 || under_1 >= 2) {\n        return;\n      }\n      // first look for a four digit year: yyyy + daymonth or daymonth + yyyy\n      possible_year_splits = [[ints[2], ints.slice(0, 2)], [ints[0], ints.slice(1, 3)]];\n      for (p = 0, len2 = possible_year_splits.length; p < len2; p++) {\n        [y, rest] = possible_year_splits[p];\n        if ((DATE_MIN_YEAR <= y && y <= DATE_MAX_YEAR)) {\n          dm = this.map_ints_to_dm(rest);\n          if (dm != null) {\n            return {\n              year: y,\n              month: dm.month,\n              day: dm.day\n            };\n          } else {\n            return;\n          }\n        }\n      }\n  // given no four-digit year, two digit years are the most flexible int to match, so\n  // try to parse a day-month out of ints[0..1] or ints[1..0]\n  // for a candidate that includes a four-digit year,\n  // when the remaining ints don't match to a day and month,\n  // it is not a date.\n      for (q = 0, len3 = possible_year_splits.length; q < len3; q++) {\n        [y, rest] = possible_year_splits[q];\n        dm = this.map_ints_to_dm(rest);\n        if (dm != null) {\n          y = this.two_to_four_digit_year(y);\n          return {\n            year: y,\n            month: dm.month,\n            day: dm.day\n          };\n        }\n      }\n    },\n    map_ints_to_dm: function(ints) {\n      var d, len1, m, o, ref;\n      ref = [ints, ints.slice().reverse()];\n      for (o = 0, len1 = ref.length; o < len1; o++) {\n        [d, m] = ref[o];\n        if ((1 <= d && d <= 31) && (1 <= m && m <= 12)) {\n          return {\n            day: d,\n            month: m\n          };\n        }\n      }\n    },\n    two_to_four_digit_year: function(year) {\n      if (year > 99) {\n        return year;\n      } else if (year > 50) {\n        // 87 -> 1987\n        return year + 1900;\n      } else {\n        // 15 -> 2015\n        return year + 2000;\n      }\n    }\n  };\n\n  return matching;\n});"]}