{"version":3,"sources":["skylark-zxcvbn.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-zxcvbn.js","sourcesContent":["define('skylark-zxcvbn/time_estimates',[],function(){\n  var time_estimates;\n\n  time_estimates = {\n    estimate_attack_times: function(guesses) {\n      var crack_times_display, crack_times_seconds, scenario, seconds;\n      crack_times_seconds = {\n        online_throttling_100_per_hour: guesses / (100 / 3600),\n        online_no_throttling_10_per_second: guesses / 10,\n        offline_slow_hashing_1e4_per_second: guesses / 1e4,\n        offline_fast_hashing_1e10_per_second: guesses / 1e10\n      };\n      crack_times_display = {};\n      for (scenario in crack_times_seconds) {\n        seconds = crack_times_seconds[scenario];\n        crack_times_display[scenario] = this.display_time(seconds);\n      }\n      return {\n        crack_times_seconds: crack_times_seconds,\n        crack_times_display: crack_times_display,\n        score: this.guesses_to_score(guesses)\n      };\n    },\n    guesses_to_score: function(guesses) {\n      var DELTA;\n      DELTA = 5;\n      if (guesses < 1e3 + DELTA) {\n        // risky password: \"too guessable\"\n        return 0;\n      } else if (guesses < 1e6 + DELTA) {\n        // modest protection from throttled online attacks: \"very guessable\"\n        return 1;\n      } else if (guesses < 1e8 + DELTA) {\n        // modest protection from unthrottled online attacks: \"somewhat guessable\"\n        return 2;\n      } else if (guesses < 1e10 + DELTA) {\n        // modest protection from offline attacks: \"safely unguessable\"\n        // assuming a salted, slow hash function like bcrypt, scrypt, PBKDF2, argon, etc\n        return 3;\n      } else {\n        // strong protection from offline attacks under same scenario: \"very unguessable\"\n        return 4;\n      }\n    },\n    display_time: function(seconds) {\n      var base, century, day, display_num, display_str, hour, minute, month, year;\n      minute = 60;\n      hour = minute * 60;\n      day = hour * 24;\n      month = day * 31;\n      year = month * 12;\n      century = year * 100;\n      [display_num, display_str] = seconds < 1 ? [null, 'less than a second'] : seconds < minute ? (base = Math.round(seconds), [base, `${base} second`]) : seconds < hour ? (base = Math.round(seconds / minute), [base, `${base} minute`]) : seconds < day ? (base = Math.round(seconds / hour), [base, `${base} hour`]) : seconds < month ? (base = Math.round(seconds / day), [base, `${base} day`]) : seconds < year ? (base = Math.round(seconds / month), [base, `${base} month`]) : seconds < century ? (base = Math.round(seconds / year), [base, `${base} year`]) : [null, 'centuries'];\n      if ((display_num != null) && display_num !== 1) {\n        display_str += 's';\n      }\n      return display_str;\n    }\n  };\n\n  return time_estimates;\n});\n\ndefine('skylark-zxcvbn/adjacency_graphs',[],function(){\n\t// generated by scripts/build_keyboard_adjacency_graphs.py\n\tvar adjacency_graphs;\n\n\tadjacency_graphs = {\n\t  qwerty: {\n\t    \"!\": [\"`~\", null, null, \"2@\", \"qQ\", null],\n\t    \"\\\"\": [\";:\", \"[{\", \"]}\", null, null, \"/?\"],\n\t    \"#\": [\"2@\", null, null, \"4$\", \"eE\", \"wW\"],\n\t    \"$\": [\"3#\", null, null, \"5%\", \"rR\", \"eE\"],\n\t    \"%\": [\"4$\", null, null, \"6^\", \"tT\", \"rR\"],\n\t    \"&\": [\"6^\", null, null, \"8*\", \"uU\", \"yY\"],\n\t    \"'\": [\";:\", \"[{\", \"]}\", null, null, \"/?\"],\n\t    \"(\": [\"8*\", null, null, \"0)\", \"oO\", \"iI\"],\n\t    \")\": [\"9(\", null, null, \"-_\", \"pP\", \"oO\"],\n\t    \"*\": [\"7&\", null, null, \"9(\", \"iI\", \"uU\"],\n\t    \"+\": [\"-_\", null, null, null, \"]}\", \"[{\"],\n\t    \",\": [\"mM\", \"kK\", \"lL\", \".>\", null, null],\n\t    \"-\": [\"0)\", null, null, \"=+\", \"[{\", \"pP\"],\n\t    \".\": [\",<\", \"lL\", \";:\", \"/?\", null, null],\n\t    \"/\": [\".>\", \";:\", \"'\\\"\", null, null, null],\n\t    \"0\": [\"9(\", null, null, \"-_\", \"pP\", \"oO\"],\n\t    \"1\": [\"`~\", null, null, \"2@\", \"qQ\", null],\n\t    \"2\": [\"1!\", null, null, \"3#\", \"wW\", \"qQ\"],\n\t    \"3\": [\"2@\", null, null, \"4$\", \"eE\", \"wW\"],\n\t    \"4\": [\"3#\", null, null, \"5%\", \"rR\", \"eE\"],\n\t    \"5\": [\"4$\", null, null, \"6^\", \"tT\", \"rR\"],\n\t    \"6\": [\"5%\", null, null, \"7&\", \"yY\", \"tT\"],\n\t    \"7\": [\"6^\", null, null, \"8*\", \"uU\", \"yY\"],\n\t    \"8\": [\"7&\", null, null, \"9(\", \"iI\", \"uU\"],\n\t    \"9\": [\"8*\", null, null, \"0)\", \"oO\", \"iI\"],\n\t    \":\": [\"lL\", \"pP\", \"[{\", \"'\\\"\", \"/?\", \".>\"],\n\t    \";\": [\"lL\", \"pP\", \"[{\", \"'\\\"\", \"/?\", \".>\"],\n\t    \"<\": [\"mM\", \"kK\", \"lL\", \".>\", null, null],\n\t    \"=\": [\"-_\", null, null, null, \"]}\", \"[{\"],\n\t    \">\": [\",<\", \"lL\", \";:\", \"/?\", null, null],\n\t    \"?\": [\".>\", \";:\", \"'\\\"\", null, null, null],\n\t    \"@\": [\"1!\", null, null, \"3#\", \"wW\", \"qQ\"],\n\t    \"A\": [null, \"qQ\", \"wW\", \"sS\", \"zZ\", null],\n\t    \"B\": [\"vV\", \"gG\", \"hH\", \"nN\", null, null],\n\t    \"C\": [\"xX\", \"dD\", \"fF\", \"vV\", null, null],\n\t    \"D\": [\"sS\", \"eE\", \"rR\", \"fF\", \"cC\", \"xX\"],\n\t    \"E\": [\"wW\", \"3#\", \"4$\", \"rR\", \"dD\", \"sS\"],\n\t    \"F\": [\"dD\", \"rR\", \"tT\", \"gG\", \"vV\", \"cC\"],\n\t    \"G\": [\"fF\", \"tT\", \"yY\", \"hH\", \"bB\", \"vV\"],\n\t    \"H\": [\"gG\", \"yY\", \"uU\", \"jJ\", \"nN\", \"bB\"],\n\t    \"I\": [\"uU\", \"8*\", \"9(\", \"oO\", \"kK\", \"jJ\"],\n\t    \"J\": [\"hH\", \"uU\", \"iI\", \"kK\", \"mM\", \"nN\"],\n\t    \"K\": [\"jJ\", \"iI\", \"oO\", \"lL\", \",<\", \"mM\"],\n\t    \"L\": [\"kK\", \"oO\", \"pP\", \";:\", \".>\", \",<\"],\n\t    \"M\": [\"nN\", \"jJ\", \"kK\", \",<\", null, null],\n\t    \"N\": [\"bB\", \"hH\", \"jJ\", \"mM\", null, null],\n\t    \"O\": [\"iI\", \"9(\", \"0)\", \"pP\", \"lL\", \"kK\"],\n\t    \"P\": [\"oO\", \"0)\", \"-_\", \"[{\", \";:\", \"lL\"],\n\t    \"Q\": [null, \"1!\", \"2@\", \"wW\", \"aA\", null],\n\t    \"R\": [\"eE\", \"4$\", \"5%\", \"tT\", \"fF\", \"dD\"],\n\t    \"S\": [\"aA\", \"wW\", \"eE\", \"dD\", \"xX\", \"zZ\"],\n\t    \"T\": [\"rR\", \"5%\", \"6^\", \"yY\", \"gG\", \"fF\"],\n\t    \"U\": [\"yY\", \"7&\", \"8*\", \"iI\", \"jJ\", \"hH\"],\n\t    \"V\": [\"cC\", \"fF\", \"gG\", \"bB\", null, null],\n\t    \"W\": [\"qQ\", \"2@\", \"3#\", \"eE\", \"sS\", \"aA\"],\n\t    \"X\": [\"zZ\", \"sS\", \"dD\", \"cC\", null, null],\n\t    \"Y\": [\"tT\", \"6^\", \"7&\", \"uU\", \"hH\", \"gG\"],\n\t    \"Z\": [null, \"aA\", \"sS\", \"xX\", null, null],\n\t    \"[\": [\"pP\", \"-_\", \"=+\", \"]}\", \"'\\\"\", \";:\"],\n\t    \"\\\\\": [\"]}\", null, null, null, null, null],\n\t    \"]\": [\"[{\", \"=+\", null, \"\\\\|\", null, \"'\\\"\"],\n\t    \"^\": [\"5%\", null, null, \"7&\", \"yY\", \"tT\"],\n\t    \"_\": [\"0)\", null, null, \"=+\", \"[{\", \"pP\"],\n\t    \"`\": [null, null, null, \"1!\", null, null],\n\t    \"a\": [null, \"qQ\", \"wW\", \"sS\", \"zZ\", null],\n\t    \"b\": [\"vV\", \"gG\", \"hH\", \"nN\", null, null],\n\t    \"c\": [\"xX\", \"dD\", \"fF\", \"vV\", null, null],\n\t    \"d\": [\"sS\", \"eE\", \"rR\", \"fF\", \"cC\", \"xX\"],\n\t    \"e\": [\"wW\", \"3#\", \"4$\", \"rR\", \"dD\", \"sS\"],\n\t    \"f\": [\"dD\", \"rR\", \"tT\", \"gG\", \"vV\", \"cC\"],\n\t    \"g\": [\"fF\", \"tT\", \"yY\", \"hH\", \"bB\", \"vV\"],\n\t    \"h\": [\"gG\", \"yY\", \"uU\", \"jJ\", \"nN\", \"bB\"],\n\t    \"i\": [\"uU\", \"8*\", \"9(\", \"oO\", \"kK\", \"jJ\"],\n\t    \"j\": [\"hH\", \"uU\", \"iI\", \"kK\", \"mM\", \"nN\"],\n\t    \"k\": [\"jJ\", \"iI\", \"oO\", \"lL\", \",<\", \"mM\"],\n\t    \"l\": [\"kK\", \"oO\", \"pP\", \";:\", \".>\", \",<\"],\n\t    \"m\": [\"nN\", \"jJ\", \"kK\", \",<\", null, null],\n\t    \"n\": [\"bB\", \"hH\", \"jJ\", \"mM\", null, null],\n\t    \"o\": [\"iI\", \"9(\", \"0)\", \"pP\", \"lL\", \"kK\"],\n\t    \"p\": [\"oO\", \"0)\", \"-_\", \"[{\", \";:\", \"lL\"],\n\t    \"q\": [null, \"1!\", \"2@\", \"wW\", \"aA\", null],\n\t    \"r\": [\"eE\", \"4$\", \"5%\", \"tT\", \"fF\", \"dD\"],\n\t    \"s\": [\"aA\", \"wW\", \"eE\", \"dD\", \"xX\", \"zZ\"],\n\t    \"t\": [\"rR\", \"5%\", \"6^\", \"yY\", \"gG\", \"fF\"],\n\t    \"u\": [\"yY\", \"7&\", \"8*\", \"iI\", \"jJ\", \"hH\"],\n\t    \"v\": [\"cC\", \"fF\", \"gG\", \"bB\", null, null],\n\t    \"w\": [\"qQ\", \"2@\", \"3#\", \"eE\", \"sS\", \"aA\"],\n\t    \"x\": [\"zZ\", \"sS\", \"dD\", \"cC\", null, null],\n\t    \"y\": [\"tT\", \"6^\", \"7&\", \"uU\", \"hH\", \"gG\"],\n\t    \"z\": [null, \"aA\", \"sS\", \"xX\", null, null],\n\t    \"{\": [\"pP\", \"-_\", \"=+\", \"]}\", \"'\\\"\", \";:\"],\n\t    \"|\": [\"]}\", null, null, null, null, null],\n\t    \"}\": [\"[{\", \"=+\", null, \"\\\\|\", null, \"'\\\"\"],\n\t    \"~\": [null, null, null, \"1!\", null, null]\n\t  },\n\t  dvorak: {\n\t    \"!\": [\"`~\", null, null, \"2@\", \"'\\\"\", null],\n\t    \"\\\"\": [null, \"1!\", \"2@\", \",<\", \"aA\", null],\n\t    \"#\": [\"2@\", null, null, \"4$\", \".>\", \",<\"],\n\t    \"$\": [\"3#\", null, null, \"5%\", \"pP\", \".>\"],\n\t    \"%\": [\"4$\", null, null, \"6^\", \"yY\", \"pP\"],\n\t    \"&\": [\"6^\", null, null, \"8*\", \"gG\", \"fF\"],\n\t    \"'\": [null, \"1!\", \"2@\", \",<\", \"aA\", null],\n\t    \"(\": [\"8*\", null, null, \"0)\", \"rR\", \"cC\"],\n\t    \")\": [\"9(\", null, null, \"[{\", \"lL\", \"rR\"],\n\t    \"*\": [\"7&\", null, null, \"9(\", \"cC\", \"gG\"],\n\t    \"+\": [\"/?\", \"]}\", null, \"\\\\|\", null, \"-_\"],\n\t    \",\": [\"'\\\"\", \"2@\", \"3#\", \".>\", \"oO\", \"aA\"],\n\t    \"-\": [\"sS\", \"/?\", \"=+\", null, null, \"zZ\"],\n\t    \".\": [\",<\", \"3#\", \"4$\", \"pP\", \"eE\", \"oO\"],\n\t    \"/\": [\"lL\", \"[{\", \"]}\", \"=+\", \"-_\", \"sS\"],\n\t    \"0\": [\"9(\", null, null, \"[{\", \"lL\", \"rR\"],\n\t    \"1\": [\"`~\", null, null, \"2@\", \"'\\\"\", null],\n\t    \"2\": [\"1!\", null, null, \"3#\", \",<\", \"'\\\"\"],\n\t    \"3\": [\"2@\", null, null, \"4$\", \".>\", \",<\"],\n\t    \"4\": [\"3#\", null, null, \"5%\", \"pP\", \".>\"],\n\t    \"5\": [\"4$\", null, null, \"6^\", \"yY\", \"pP\"],\n\t    \"6\": [\"5%\", null, null, \"7&\", \"fF\", \"yY\"],\n\t    \"7\": [\"6^\", null, null, \"8*\", \"gG\", \"fF\"],\n\t    \"8\": [\"7&\", null, null, \"9(\", \"cC\", \"gG\"],\n\t    \"9\": [\"8*\", null, null, \"0)\", \"rR\", \"cC\"],\n\t    \":\": [null, \"aA\", \"oO\", \"qQ\", null, null],\n\t    \";\": [null, \"aA\", \"oO\", \"qQ\", null, null],\n\t    \"<\": [\"'\\\"\", \"2@\", \"3#\", \".>\", \"oO\", \"aA\"],\n\t    \"=\": [\"/?\", \"]}\", null, \"\\\\|\", null, \"-_\"],\n\t    \">\": [\",<\", \"3#\", \"4$\", \"pP\", \"eE\", \"oO\"],\n\t    \"?\": [\"lL\", \"[{\", \"]}\", \"=+\", \"-_\", \"sS\"],\n\t    \"@\": [\"1!\", null, null, \"3#\", \",<\", \"'\\\"\"],\n\t    \"A\": [null, \"'\\\"\", \",<\", \"oO\", \";:\", null],\n\t    \"B\": [\"xX\", \"dD\", \"hH\", \"mM\", null, null],\n\t    \"C\": [\"gG\", \"8*\", \"9(\", \"rR\", \"tT\", \"hH\"],\n\t    \"D\": [\"iI\", \"fF\", \"gG\", \"hH\", \"bB\", \"xX\"],\n\t    \"E\": [\"oO\", \".>\", \"pP\", \"uU\", \"jJ\", \"qQ\"],\n\t    \"F\": [\"yY\", \"6^\", \"7&\", \"gG\", \"dD\", \"iI\"],\n\t    \"G\": [\"fF\", \"7&\", \"8*\", \"cC\", \"hH\", \"dD\"],\n\t    \"H\": [\"dD\", \"gG\", \"cC\", \"tT\", \"mM\", \"bB\"],\n\t    \"I\": [\"uU\", \"yY\", \"fF\", \"dD\", \"xX\", \"kK\"],\n\t    \"J\": [\"qQ\", \"eE\", \"uU\", \"kK\", null, null],\n\t    \"K\": [\"jJ\", \"uU\", \"iI\", \"xX\", null, null],\n\t    \"L\": [\"rR\", \"0)\", \"[{\", \"/?\", \"sS\", \"nN\"],\n\t    \"M\": [\"bB\", \"hH\", \"tT\", \"wW\", null, null],\n\t    \"N\": [\"tT\", \"rR\", \"lL\", \"sS\", \"vV\", \"wW\"],\n\t    \"O\": [\"aA\", \",<\", \".>\", \"eE\", \"qQ\", \";:\"],\n\t    \"P\": [\".>\", \"4$\", \"5%\", \"yY\", \"uU\", \"eE\"],\n\t    \"Q\": [\";:\", \"oO\", \"eE\", \"jJ\", null, null],\n\t    \"R\": [\"cC\", \"9(\", \"0)\", \"lL\", \"nN\", \"tT\"],\n\t    \"S\": [\"nN\", \"lL\", \"/?\", \"-_\", \"zZ\", \"vV\"],\n\t    \"T\": [\"hH\", \"cC\", \"rR\", \"nN\", \"wW\", \"mM\"],\n\t    \"U\": [\"eE\", \"pP\", \"yY\", \"iI\", \"kK\", \"jJ\"],\n\t    \"V\": [\"wW\", \"nN\", \"sS\", \"zZ\", null, null],\n\t    \"W\": [\"mM\", \"tT\", \"nN\", \"vV\", null, null],\n\t    \"X\": [\"kK\", \"iI\", \"dD\", \"bB\", null, null],\n\t    \"Y\": [\"pP\", \"5%\", \"6^\", \"fF\", \"iI\", \"uU\"],\n\t    \"Z\": [\"vV\", \"sS\", \"-_\", null, null, null],\n\t    \"[\": [\"0)\", null, null, \"]}\", \"/?\", \"lL\"],\n\t    \"\\\\\": [\"=+\", null, null, null, null, null],\n\t    \"]\": [\"[{\", null, null, null, \"=+\", \"/?\"],\n\t    \"^\": [\"5%\", null, null, \"7&\", \"fF\", \"yY\"],\n\t    \"_\": [\"sS\", \"/?\", \"=+\", null, null, \"zZ\"],\n\t    \"`\": [null, null, null, \"1!\", null, null],\n\t    \"a\": [null, \"'\\\"\", \",<\", \"oO\", \";:\", null],\n\t    \"b\": [\"xX\", \"dD\", \"hH\", \"mM\", null, null],\n\t    \"c\": [\"gG\", \"8*\", \"9(\", \"rR\", \"tT\", \"hH\"],\n\t    \"d\": [\"iI\", \"fF\", \"gG\", \"hH\", \"bB\", \"xX\"],\n\t    \"e\": [\"oO\", \".>\", \"pP\", \"uU\", \"jJ\", \"qQ\"],\n\t    \"f\": [\"yY\", \"6^\", \"7&\", \"gG\", \"dD\", \"iI\"],\n\t    \"g\": [\"fF\", \"7&\", \"8*\", \"cC\", \"hH\", \"dD\"],\n\t    \"h\": [\"dD\", \"gG\", \"cC\", \"tT\", \"mM\", \"bB\"],\n\t    \"i\": [\"uU\", \"yY\", \"fF\", \"dD\", \"xX\", \"kK\"],\n\t    \"j\": [\"qQ\", \"eE\", \"uU\", \"kK\", null, null],\n\t    \"k\": [\"jJ\", \"uU\", \"iI\", \"xX\", null, null],\n\t    \"l\": [\"rR\", \"0)\", \"[{\", \"/?\", \"sS\", \"nN\"],\n\t    \"m\": [\"bB\", \"hH\", \"tT\", \"wW\", null, null],\n\t    \"n\": [\"tT\", \"rR\", \"lL\", \"sS\", \"vV\", \"wW\"],\n\t    \"o\": [\"aA\", \",<\", \".>\", \"eE\", \"qQ\", \";:\"],\n\t    \"p\": [\".>\", \"4$\", \"5%\", \"yY\", \"uU\", \"eE\"],\n\t    \"q\": [\";:\", \"oO\", \"eE\", \"jJ\", null, null],\n\t    \"r\": [\"cC\", \"9(\", \"0)\", \"lL\", \"nN\", \"tT\"],\n\t    \"s\": [\"nN\", \"lL\", \"/?\", \"-_\", \"zZ\", \"vV\"],\n\t    \"t\": [\"hH\", \"cC\", \"rR\", \"nN\", \"wW\", \"mM\"],\n\t    \"u\": [\"eE\", \"pP\", \"yY\", \"iI\", \"kK\", \"jJ\"],\n\t    \"v\": [\"wW\", \"nN\", \"sS\", \"zZ\", null, null],\n\t    \"w\": [\"mM\", \"tT\", \"nN\", \"vV\", null, null],\n\t    \"x\": [\"kK\", \"iI\", \"dD\", \"bB\", null, null],\n\t    \"y\": [\"pP\", \"5%\", \"6^\", \"fF\", \"iI\", \"uU\"],\n\t    \"z\": [\"vV\", \"sS\", \"-_\", null, null, null],\n\t    \"{\": [\"0)\", null, null, \"]}\", \"/?\", \"lL\"],\n\t    \"|\": [\"=+\", null, null, null, null, null],\n\t    \"}\": [\"[{\", null, null, null, \"=+\", \"/?\"],\n\t    \"~\": [null, null, null, \"1!\", null, null]\n\t  },\n\t  keypad: {\n\t    \"*\": [\"/\", null, null, null, \"-\", \"+\", \"9\", \"8\"],\n\t    \"+\": [\"9\", \"*\", \"-\", null, null, null, null, \"6\"],\n\t    \"-\": [\"*\", null, null, null, null, null, \"+\", \"9\"],\n\t    \".\": [\"0\", \"2\", \"3\", null, null, null, null, null],\n\t    \"/\": [null, null, null, null, \"*\", \"9\", \"8\", \"7\"],\n\t    \"0\": [null, \"1\", \"2\", \"3\", \".\", null, null, null],\n\t    \"1\": [null, null, \"4\", \"5\", \"2\", \"0\", null, null],\n\t    \"2\": [\"1\", \"4\", \"5\", \"6\", \"3\", \".\", \"0\", null],\n\t    \"3\": [\"2\", \"5\", \"6\", null, null, null, \".\", \"0\"],\n\t    \"4\": [null, null, \"7\", \"8\", \"5\", \"2\", \"1\", null],\n\t    \"5\": [\"4\", \"7\", \"8\", \"9\", \"6\", \"3\", \"2\", \"1\"],\n\t    \"6\": [\"5\", \"8\", \"9\", \"+\", null, null, \"3\", \"2\"],\n\t    \"7\": [null, null, null, \"/\", \"8\", \"5\", \"4\", null],\n\t    \"8\": [\"7\", null, \"/\", \"*\", \"9\", \"6\", \"5\", \"4\"],\n\t    \"9\": [\"8\", \"/\", \"*\", \"-\", \"+\", null, \"6\", \"5\"]\n\t  },\n\t  mac_keypad: {\n\t    \"*\": [\"/\", null, null, null, null, null, \"-\", \"9\"],\n\t    \"+\": [\"6\", \"9\", \"-\", null, null, null, null, \"3\"],\n\t    \"-\": [\"9\", \"/\", \"*\", null, null, null, \"+\", \"6\"],\n\t    \".\": [\"0\", \"2\", \"3\", null, null, null, null, null],\n\t    \"/\": [\"=\", null, null, null, \"*\", \"-\", \"9\", \"8\"],\n\t    \"0\": [null, \"1\", \"2\", \"3\", \".\", null, null, null],\n\t    \"1\": [null, null, \"4\", \"5\", \"2\", \"0\", null, null],\n\t    \"2\": [\"1\", \"4\", \"5\", \"6\", \"3\", \".\", \"0\", null],\n\t    \"3\": [\"2\", \"5\", \"6\", \"+\", null, null, \".\", \"0\"],\n\t    \"4\": [null, null, \"7\", \"8\", \"5\", \"2\", \"1\", null],\n\t    \"5\": [\"4\", \"7\", \"8\", \"9\", \"6\", \"3\", \"2\", \"1\"],\n\t    \"6\": [\"5\", \"8\", \"9\", \"-\", \"+\", null, \"3\", \"2\"],\n\t    \"7\": [null, null, null, \"=\", \"8\", \"5\", \"4\", null],\n\t    \"8\": [\"7\", null, \"=\", \"/\", \"9\", \"6\", \"5\", \"4\"],\n\t    \"9\": [\"8\", \"=\", \"/\", \"*\", \"-\", \"+\", \"6\", \"5\"],\n\t    \"=\": [null, null, null, null, \"/\", \"9\", \"8\", \"7\"]\n\t  }\n\t};\n\n\treturn adjacency_graphs;\n});\n\ndefine('skylark-zxcvbn/scoring',[\n  './adjacency_graphs'\n],function(adjacency_graphs){\n\n  var BRUTEFORCE_CARDINALITY, MIN_GUESSES_BEFORE_GROWING_SEQUENCE, MIN_SUBMATCH_GUESSES_MULTI_CHAR, MIN_SUBMATCH_GUESSES_SINGLE_CHAR, adjacency_graphs, calc_average_degree, k, scoring, v;\n\n  // on qwerty, 'g' has degree 6, being adjacent to 'ftyhbv'. '\\' has degree 1.\n  // this calculates the average over all keys.\n  calc_average_degree = function(graph) {\n    var average, k, key, n, neighbors, v;\n    average = 0;\n    for (key in graph) {\n      neighbors = graph[key];\n      average += ((function() {\n        var len, o, results;\n        results = [];\n        for (o = 0, len = neighbors.length; o < len; o++) {\n          n = neighbors[o];\n          if (n) {\n            results.push(n);\n          }\n        }\n        return results;\n      })()).length;\n    }\n    average /= ((function() {\n      var results;\n      results = [];\n      for (k in graph) {\n        v = graph[k];\n        results.push(k);\n      }\n      return results;\n    })()).length;\n    return average;\n  };\n\n  BRUTEFORCE_CARDINALITY = 10;\n\n  MIN_GUESSES_BEFORE_GROWING_SEQUENCE = 10000;\n\n  MIN_SUBMATCH_GUESSES_SINGLE_CHAR = 10;\n\n  MIN_SUBMATCH_GUESSES_MULTI_CHAR = 50;\n\n  scoring = {\n    nCk: function(n, k) {\n      var d, o, r, ref;\n      if (k > n) {\n        // http://blog.plover.com/math/choose.html\n        return 0;\n      }\n      if (k === 0) {\n        return 1;\n      }\n      r = 1;\n      for (d = o = 1, ref = k; (1 <= ref ? o <= ref : o >= ref); d = 1 <= ref ? ++o : --o) {\n        r *= n;\n        r /= d;\n        n -= 1;\n      }\n      return r;\n    },\n    log10: function(n) {\n      return Math.log(n) / Math.log(10); // IE doesn't support Math.log10 :(\n    },\n    log2: function(n) {\n      return Math.log(n) / Math.log(2);\n    },\n    factorial: function(n) {\n      var f, i, o, ref;\n      if (n < 2) {\n        // unoptimized, called only on small n\n        return 1;\n      }\n      f = 1;\n      for (i = o = 2, ref = n; (2 <= ref ? o <= ref : o >= ref); i = 2 <= ref ? ++o : --o) {\n        f *= i;\n      }\n      return f;\n    },\n    // ------------------------------------------------------------------------------\n    // search --- most guessable match sequence -------------------------------------\n    // ------------------------------------------------------------------------------\n\n    // takes a sequence of overlapping matches, returns the non-overlapping sequence with\n    // minimum guesses. the following is a O(l_max * (n + m)) dynamic programming algorithm\n    // for a length-n password with m candidate matches. l_max is the maximum optimal\n    // sequence length spanning each prefix of the password. In practice it rarely exceeds 5 and the\n    // search terminates rapidly.\n\n    // the optimal \"minimum guesses\" sequence is here defined to be the sequence that\n    // minimizes the following function:\n\n    //    g = l! * Product(m.guesses for m in sequence) + D^(l - 1)\n\n    // where l is the length of the sequence.\n\n    // the factorial term is the number of ways to order l patterns.\n\n    // the D^(l-1) term is another length penalty, roughly capturing the idea that an\n    // attacker will try lower-length sequences first before trying length-l sequences.\n\n    // for example, consider a sequence that is date-repeat-dictionary.\n    //  - an attacker would need to try other date-repeat-dictionary combinations,\n    //    hence the product term.\n    //  - an attacker would need to try repeat-date-dictionary, dictionary-repeat-date,\n    //    ..., hence the factorial term.\n    //  - an attacker would also likely try length-1 (dictionary) and length-2 (dictionary-date)\n    //    sequences before length-3. assuming at minimum D guesses per pattern type,\n    //    D^(l-1) approximates Sum(D^i for i in [1..l-1]\n\n    // ------------------------------------------------------------------------------\n    most_guessable_match_sequence: function(password, matches, _exclude_additive = false) {\n      var _, bruteforce_update, guesses, k, l, len, len1, len2, lst, m, make_bruteforce_match, matches_by_j, n, o, optimal, optimal_l, optimal_match_sequence, q, ref, ref1, u, unwind, update, w;\n      n = password.length;\n      // partition matches into sublists according to ending index j\n      matches_by_j = (function() {\n        var o, ref, results;\n        results = [];\n        for (_ = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); _ = 0 <= ref ? ++o : --o) {\n          results.push([]);\n        }\n        return results;\n      })();\n      for (o = 0, len = matches.length; o < len; o++) {\n        m = matches[o];\n        matches_by_j[m.j].push(m);\n      }\n  // small detail: for deterministic output, sort each sublist by i.\n      for (q = 0, len1 = matches_by_j.length; q < len1; q++) {\n        lst = matches_by_j[q];\n        lst.sort(function(m1, m2) {\n          return m1.i - m2.i;\n        });\n      }\n      optimal = {\n        // optimal.m[k][l] holds final match in the best length-l match sequence covering the\n        // password prefix up to k, inclusive.\n        // if there is no length-l sequence that scores better (fewer guesses) than\n        // a shorter match sequence spanning the same prefix, optimal.m[k][l] is undefined.\n        m: (function() {\n          var ref, results, u;\n          results = [];\n          for (_ = u = 0, ref = n; (0 <= ref ? u < ref : u > ref); _ = 0 <= ref ? ++u : --u) {\n            results.push({});\n          }\n          return results;\n        })(),\n        // same structure as optimal.m -- holds the product term Prod(m.guesses for m in sequence).\n        // optimal.pi allows for fast (non-looping) updates to the minimization function.\n        pi: (function() {\n          var ref, results, u;\n          results = [];\n          for (_ = u = 0, ref = n; (0 <= ref ? u < ref : u > ref); _ = 0 <= ref ? ++u : --u) {\n            results.push({});\n          }\n          return results;\n        })(),\n        // same structure as optimal.m -- holds the overall metric.\n        g: (function() {\n          var ref, results, u;\n          results = [];\n          for (_ = u = 0, ref = n; (0 <= ref ? u < ref : u > ref); _ = 0 <= ref ? ++u : --u) {\n            results.push({});\n          }\n          return results;\n        })()\n      };\n      // helper: considers whether a length-l sequence ending at match m is better (fewer guesses)\n      // than previously encountered sequences, updating state if so.\n      update = (m, l) => {\n        var competing_g, competing_l, g, k, pi, ref;\n        k = m.j;\n        pi = this.estimate_guesses(m, password);\n        if (l > 1) {\n          // we're considering a length-l sequence ending with match m:\n          // obtain the product term in the minimization function by multiplying m's guesses\n          // by the product of the length-(l-1) sequence ending just before m, at m.i - 1.\n          pi *= optimal.pi[m.i - 1][l - 1];\n        }\n        // calculate the minimization func\n        g = this.factorial(l) * pi;\n        if (!_exclude_additive) {\n          g += Math.pow(MIN_GUESSES_BEFORE_GROWING_SEQUENCE, l - 1);\n        }\n        ref = optimal.g[k];\n        // update state if new best.\n        // first see if any competing sequences covering this prefix, with l or fewer matches,\n        // fare better than this sequence. if so, skip it and return.\n        for (competing_l in ref) {\n          competing_g = ref[competing_l];\n          if (competing_l > l) {\n            continue;\n          }\n          if (competing_g <= g) {\n            return;\n          }\n        }\n        // this sequence might be part of the final optimal sequence.\n        optimal.g[k][l] = g;\n        optimal.m[k][l] = m;\n        return optimal.pi[k][l] = pi;\n      };\n      // helper: evaluate bruteforce matches ending at k.\n      bruteforce_update = (k) => {\n        var i, l, last_m, ref, results, u;\n        // see if a single bruteforce match spanning the k-prefix is optimal.\n        m = make_bruteforce_match(0, k);\n        update(m, 1);\n        results = [];\n        for (i = u = 1, ref = k; (1 <= ref ? u <= ref : u >= ref); i = 1 <= ref ? ++u : --u) {\n          // generate k bruteforce matches, spanning from (i=1, j=k) up to (i=k, j=k).\n          // see if adding these new matches to any of the sequences in optimal[i-1]\n          // leads to new bests.\n          m = make_bruteforce_match(i, k);\n          results.push((function() {\n            var ref1, results1;\n            ref1 = optimal.m[i - 1];\n            results1 = [];\n            for (l in ref1) {\n              last_m = ref1[l];\n              l = parseInt(l);\n              if (last_m.pattern === 'bruteforce') {\n                // corner: an optimal sequence will never have two adjacent bruteforce matches.\n                // it is strictly better to have a single bruteforce match spanning the same region:\n                // same contribution to the guess product with a lower length.\n                // --> safe to skip those cases.\n                continue;\n              }\n              // try adding m to this length-l sequence.\n              results1.push(update(m, l + 1));\n            }\n            return results1;\n          })());\n        }\n        return results;\n      };\n      // helper: make bruteforce match objects spanning i to j, inclusive.\n      make_bruteforce_match = (i, j) => {\n        return {\n          pattern: 'bruteforce',\n          token: password.slice(i, +j + 1 || 9e9),\n          i: i,\n          j: j\n        };\n      };\n      // helper: step backwards through optimal.m starting at the end,\n      // constructing the final optimal match sequence.\n      unwind = (n) => {\n        var candidate_g, candidate_l, g, k, l, optimal_match_sequence, ref;\n        optimal_match_sequence = [];\n        k = n - 1;\n        // find the final best sequence length and score\n        l = void 0;\n        g = 2e308;\n        ref = optimal.g[k];\n        for (candidate_l in ref) {\n          candidate_g = ref[candidate_l];\n          if (candidate_g < g) {\n            l = candidate_l;\n            g = candidate_g;\n          }\n        }\n        while (k >= 0) {\n          m = optimal.m[k][l];\n          optimal_match_sequence.unshift(m);\n          k = m.i - 1;\n          l--;\n        }\n        return optimal_match_sequence;\n      };\n      for (k = u = 0, ref = n; (0 <= ref ? u < ref : u > ref); k = 0 <= ref ? ++u : --u) {\n        ref1 = matches_by_j[k];\n        for (w = 0, len2 = ref1.length; w < len2; w++) {\n          m = ref1[w];\n          if (m.i > 0) {\n            for (l in optimal.m[m.i - 1]) {\n              l = parseInt(l);\n              update(m, l + 1);\n            }\n          } else {\n            update(m, 1);\n          }\n        }\n        bruteforce_update(k);\n      }\n      optimal_match_sequence = unwind(n);\n      optimal_l = optimal_match_sequence.length;\n      // corner: empty password\n      if (password.length === 0) {\n        guesses = 1;\n      } else {\n        guesses = optimal.g[n - 1][optimal_l];\n      }\n      return {\n        // final result object\n        password: password,\n        guesses: guesses,\n        guesses_log10: this.log10(guesses),\n        sequence: optimal_match_sequence\n      };\n    },\n    // ------------------------------------------------------------------------------\n    // guess estimation -- one function per match pattern ---------------------------\n    // ------------------------------------------------------------------------------\n    estimate_guesses: function(match, password) {\n      var estimation_functions, guesses, min_guesses;\n      if (match.guesses != null) {\n        return match.guesses; // a match's guess estimate doesn't change. cache it.\n      }\n      min_guesses = 1;\n      if (match.token.length < password.length) {\n        min_guesses = match.token.length === 1 ? MIN_SUBMATCH_GUESSES_SINGLE_CHAR : MIN_SUBMATCH_GUESSES_MULTI_CHAR;\n      }\n      estimation_functions = {\n        bruteforce: this.bruteforce_guesses,\n        dictionary: this.dictionary_guesses,\n        spatial: this.spatial_guesses,\n        repeat: this.repeat_guesses,\n        sequence: this.sequence_guesses,\n        regex: this.regex_guesses,\n        date: this.date_guesses\n      };\n      guesses = estimation_functions[match.pattern].call(this, match);\n      match.guesses = Math.max(guesses, min_guesses);\n      match.guesses_log10 = this.log10(match.guesses);\n      return match.guesses;\n    },\n    bruteforce_guesses: function(match) {\n      var guesses, min_guesses;\n      guesses = Math.pow(BRUTEFORCE_CARDINALITY, match.token.length);\n      if (guesses === Number.POSITIVE_INFINITY) {\n        guesses = Number.MAX_VALUE;\n      }\n      min_guesses = match.token.length === 1 ? MIN_SUBMATCH_GUESSES_SINGLE_CHAR + 1 : MIN_SUBMATCH_GUESSES_MULTI_CHAR + 1;\n      return Math.max(guesses, min_guesses);\n    },\n    repeat_guesses: function(match) {\n      return match.base_guesses * match.repeat_count;\n    },\n    sequence_guesses: function(match) {\n      var base_guesses, first_chr;\n      first_chr = match.token.charAt(0);\n      // lower guesses for obvious starting points\n      if (first_chr === 'a' || first_chr === 'A' || first_chr === 'z' || first_chr === 'Z' || first_chr === '0' || first_chr === '1' || first_chr === '9') {\n        base_guesses = 4;\n      } else {\n        if (first_chr.match(/\\d/)) {\n          base_guesses = 10; // digits\n        } else {\n          // could give a higher base for uppercase,\n          // assigning 26 to both upper and lower sequences is more conservative.\n          base_guesses = 26;\n        }\n      }\n      if (!match.ascending) {\n        // need to try a descending sequence in addition to every ascending sequence ->\n        // 2x guesses\n        base_guesses *= 2;\n      }\n      return base_guesses * match.token.length;\n    },\n    MIN_YEAR_SPACE: 20,\n    REFERENCE_YEAR: new Date().getFullYear(),\n    regex_guesses: function(match) {\n      var char_class_bases, year_space;\n      char_class_bases = {\n        alpha_lower: 26,\n        alpha_upper: 26,\n        alpha: 52,\n        alphanumeric: 62,\n        digits: 10,\n        symbols: 33\n      };\n      if (match.regex_name in char_class_bases) {\n        return Math.pow(char_class_bases[match.regex_name], match.token.length);\n      } else {\n        switch (match.regex_name) {\n          case 'recent_year':\n            // conservative estimate of year space: num years from REFERENCE_YEAR.\n            // if year is close to REFERENCE_YEAR, estimate a year space of MIN_YEAR_SPACE.\n            year_space = Math.abs(parseInt(match.regex_match[0]) - this.REFERENCE_YEAR);\n            year_space = Math.max(year_space, this.MIN_YEAR_SPACE);\n            return year_space;\n        }\n      }\n    },\n    date_guesses: function(match) {\n      var guesses, year_space;\n      // base guesses: (year distance from REFERENCE_YEAR) * num_days * num_years\n      year_space = Math.max(Math.abs(match.year - this.REFERENCE_YEAR), this.MIN_YEAR_SPACE);\n      guesses = year_space * 365;\n      if (match.separator) {\n        // add factor of 4 for separator selection (one of ~4 choices)\n        guesses *= 4;\n      }\n      return guesses;\n    },\n    KEYBOARD_AVERAGE_DEGREE: calc_average_degree(adjacency_graphs.qwerty),\n    // slightly different for keypad/mac keypad, but close enough\n    KEYPAD_AVERAGE_DEGREE: calc_average_degree(adjacency_graphs.keypad),\n    KEYBOARD_STARTING_POSITIONS: ((function() {\n      var ref, results;\n      ref = adjacency_graphs.qwerty;\n      results = [];\n      for (k in ref) {\n        v = ref[k];\n        results.push(k);\n      }\n      return results;\n    })()).length,\n    KEYPAD_STARTING_POSITIONS: ((function() {\n      var ref, results;\n      ref = adjacency_graphs.keypad;\n      results = [];\n      for (k in ref) {\n        v = ref[k];\n        results.push(k);\n      }\n      return results;\n    })()).length,\n    spatial_guesses: function(match) {\n      var L, S, U, d, guesses, i, j, o, possible_turns, q, ref, ref1, ref2, ref3, s, shifted_variations, t, u;\n      if ((ref = match.graph) === 'qwerty' || ref === 'dvorak') {\n        s = this.KEYBOARD_STARTING_POSITIONS;\n        d = this.KEYBOARD_AVERAGE_DEGREE;\n      } else {\n        s = this.KEYPAD_STARTING_POSITIONS;\n        d = this.KEYPAD_AVERAGE_DEGREE;\n      }\n      guesses = 0;\n      L = match.token.length;\n      t = match.turns;\n  // estimate the number of possible patterns w/ length L or less with t turns or less.\n      for (i = o = 2, ref1 = L; (2 <= ref1 ? o <= ref1 : o >= ref1); i = 2 <= ref1 ? ++o : --o) {\n        possible_turns = Math.min(t, i - 1);\n        for (j = q = 1, ref2 = possible_turns; (1 <= ref2 ? q <= ref2 : q >= ref2); j = 1 <= ref2 ? ++q : --q) {\n          guesses += this.nCk(i - 1, j - 1) * s * Math.pow(d, j);\n        }\n      }\n      // add extra guesses for shifted keys. (% instead of 5, A instead of a.)\n      // math is similar to extra guesses of l33t substitutions in dictionary matches.\n      if (match.shifted_count) {\n        S = match.shifted_count;\n        U = match.token.length - match.shifted_count; // unshifted count\n        if (S === 0 || U === 0) {\n          guesses *= 2;\n        } else {\n          shifted_variations = 0;\n          for (i = u = 1, ref3 = Math.min(S, U); (1 <= ref3 ? u <= ref3 : u >= ref3); i = 1 <= ref3 ? ++u : --u) {\n            shifted_variations += this.nCk(S + U, i);\n          }\n          guesses *= shifted_variations;\n        }\n      }\n      return guesses;\n    },\n    dictionary_guesses: function(match) {\n      var reversed_variations;\n      match.base_guesses = match.rank; // keep these as properties for display purposes\n      match.uppercase_variations = this.uppercase_variations(match);\n      match.l33t_variations = this.l33t_variations(match);\n      reversed_variations = match.reversed && 2 || 1;\n      return match.base_guesses * match.uppercase_variations * match.l33t_variations * reversed_variations;\n    },\n    START_UPPER: /^[A-Z][^A-Z]+$/,\n    END_UPPER: /^[^A-Z]+[A-Z]$/,\n    ALL_UPPER: /^[^a-z]+$/,\n    ALL_LOWER: /^[^A-Z]+$/,\n    uppercase_variations: function(match) {\n      var L, U, chr, i, len, o, q, ref, ref1, regex, variations, word;\n      word = match.token;\n      if (word.match(this.ALL_LOWER) || word.toLowerCase() === word) {\n        return 1;\n      }\n      ref = [this.START_UPPER, this.END_UPPER, this.ALL_UPPER];\n      // a capitalized word is the most common capitalization scheme,\n      // so it only doubles the search space (uncapitalized + capitalized).\n      // allcaps and end-capitalized are common enough too, underestimate as 2x factor to be safe.\n      for (o = 0, len = ref.length; o < len; o++) {\n        regex = ref[o];\n        if (word.match(regex)) {\n          return 2;\n        }\n      }\n      // otherwise calculate the number of ways to capitalize U+L uppercase+lowercase letters\n      // with U uppercase letters or less. or, if there's more uppercase than lower (for eg. PASSwORD),\n      // the number of ways to lowercase U+L letters with L lowercase letters or less.\n      U = ((function() {\n        var len1, q, ref1, results;\n        ref1 = word.split('');\n        results = [];\n        for (q = 0, len1 = ref1.length; q < len1; q++) {\n          chr = ref1[q];\n          if (chr.match(/[A-Z]/)) {\n            results.push(chr);\n          }\n        }\n        return results;\n      })()).length;\n      L = ((function() {\n        var len1, q, ref1, results;\n        ref1 = word.split('');\n        results = [];\n        for (q = 0, len1 = ref1.length; q < len1; q++) {\n          chr = ref1[q];\n          if (chr.match(/[a-z]/)) {\n            results.push(chr);\n          }\n        }\n        return results;\n      })()).length;\n      variations = 0;\n      for (i = q = 1, ref1 = Math.min(U, L); (1 <= ref1 ? q <= ref1 : q >= ref1); i = 1 <= ref1 ? ++q : --q) {\n        variations += this.nCk(U + L, i);\n      }\n      return variations;\n    },\n    l33t_variations: function(match) {\n      var S, U, chr, chrs, i, o, p, possibilities, ref, ref1, subbed, unsubbed, variations;\n      if (!match.l33t) {\n        return 1;\n      }\n      variations = 1;\n      ref = match.sub;\n      for (subbed in ref) {\n        unsubbed = ref[subbed];\n        // lower-case match.token before calculating: capitalization shouldn't affect l33t calc.\n        chrs = match.token.toLowerCase().split('');\n        S = ((function() {\n          var len, o, results;\n          results = [];\n          for (o = 0, len = chrs.length; o < len; o++) {\n            chr = chrs[o];\n            if (chr === subbed) {\n              results.push(chr);\n            }\n          }\n          return results;\n        })()).length; // num of subbed chars\n        U = ((function() {\n          var len, o, results;\n          results = [];\n          for (o = 0, len = chrs.length; o < len; o++) {\n            chr = chrs[o];\n            if (chr === unsubbed) {\n              results.push(chr);\n            }\n          }\n          return results;\n        })()).length; // num of unsubbed chars\n        if (S === 0 || U === 0) {\n          // for this sub, password is either fully subbed (444) or fully unsubbed (aaa)\n          // treat that as doubling the space (attacker needs to try fully subbed chars in addition to\n          // unsubbed.)\n          variations *= 2;\n        } else {\n          // this case is similar to capitalization:\n          // with aa44a, U = 3, S = 2, attacker needs to try unsubbed + one sub + two subs\n          p = Math.min(U, S);\n          possibilities = 0;\n          for (i = o = 1, ref1 = p; (1 <= ref1 ? o <= ref1 : o >= ref1); i = 1 <= ref1 ? ++o : --o) {\n            possibilities += this.nCk(U + S, i);\n          }\n          variations *= possibilities;\n        }\n      }\n      return variations;\n    }\n  };\n\n  // utilities --------------------------------------------------------------------\n  return scoring;\n\n});\n\n  var feedback, scoring;\ndefine('skylark-zxcvbn/feedback',[\n  './scoring'\n],function(scoring){\n\n\n  feedback = {\n    default_feedback: {\n      warning: '',\n      suggestions: [\"Use a few words, avoid common phrases\", \"No need for symbols, digits, or uppercase letters\"]\n    },\n    get_feedback: function(score, sequence) {\n      var extra_feedback, i, len, longest_match, match, ref;\n      if (sequence.length === 0) {\n        // starting feedback\n        return this.default_feedback;\n      }\n      // no feedback if score is good or great.\n      if (score > 2) {\n        return {\n          warning: '',\n          suggestions: []\n        };\n      }\n      // tie feedback to the longest match for longer sequences\n      longest_match = sequence[0];\n      ref = sequence.slice(1);\n      for (i = 0, len = ref.length; i < len; i++) {\n        match = ref[i];\n        if (match.token.length > longest_match.token.length) {\n          longest_match = match;\n        }\n      }\n      feedback = this.get_match_feedback(longest_match, sequence.length === 1);\n      extra_feedback = 'Add another word or two. Uncommon words are better.';\n      if (feedback != null) {\n        feedback.suggestions.unshift(extra_feedback);\n        if (feedback.warning == null) {\n          feedback.warning = '';\n        }\n      } else {\n        feedback = {\n          warning: '',\n          suggestions: [extra_feedback]\n        };\n      }\n      return feedback;\n    },\n    get_match_feedback: function(match, is_sole_match) {\n      var layout, warning;\n      switch (match.pattern) {\n        case 'dictionary':\n          return this.get_dictionary_match_feedback(match, is_sole_match);\n        case 'spatial':\n          layout = match.graph.toUpperCase();\n          warning = match.turns === 1 ? 'Straight rows of keys are easy to guess' : 'Short keyboard patterns are easy to guess';\n          return {\n            warning: warning,\n            suggestions: ['Use a longer keyboard pattern with more turns']\n          };\n        case 'repeat':\n          warning = match.base_token.length === 1 ? 'Repeats like \"aaa\" are easy to guess' : 'Repeats like \"abcabcabc\" are only slightly harder to guess than \"abc\"';\n          return {\n            warning: warning,\n            suggestions: ['Avoid repeated words and characters']\n          };\n        case 'sequence':\n          return {\n            warning: \"Sequences like abc or 6543 are easy to guess\",\n            suggestions: ['Avoid sequences']\n          };\n        case 'regex':\n          if (match.regex_name === 'recent_year') {\n            return {\n              warning: \"Recent years are easy to guess\",\n              suggestions: ['Avoid recent years', 'Avoid years that are associated with you']\n            };\n          }\n          break;\n        case 'date':\n          return {\n            warning: \"Dates are often easy to guess\",\n            suggestions: ['Avoid dates and years that are associated with you']\n          };\n      }\n    },\n    get_dictionary_match_feedback: function(match, is_sole_match) {\n      var ref, result, suggestions, warning, word;\n      warning = match.dictionary_name === 'passwords' ? is_sole_match && !match.l33t && !match.reversed ? match.rank <= 10 ? 'This is a top-10 common password' : match.rank <= 100 ? 'This is a top-100 common password' : 'This is a very common password' : match.guesses_log10 <= 4 ? 'This is similar to a commonly used password' : void 0 : match.dictionary_name === 'english_wikipedia' ? is_sole_match ? 'A word by itself is easy to guess' : void 0 : (ref = match.dictionary_name) === 'surnames' || ref === 'male_names' || ref === 'female_names' ? is_sole_match ? 'Names and surnames by themselves are easy to guess' : 'Common names and surnames are easy to guess' : '';\n      suggestions = [];\n      word = match.token;\n      if (word.match(scoring.START_UPPER)) {\n        suggestions.push(\"Capitalization doesn't help very much\");\n      } else if (word.match(scoring.ALL_UPPER) && word.toLowerCase() !== word) {\n        suggestions.push(\"All-uppercase is almost as easy to guess as all-lowercase\");\n      }\n      if (match.reversed && match.token.length >= 4) {\n        suggestions.push(\"Reversed words aren't much harder to guess\");\n      }\n      if (match.l33t) {\n        suggestions.push(\"Predictable substitutions like '@' instead of 'a' don't help very much\");\n      }\n      result = {\n        warning: warning,\n        suggestions: suggestions\n      };\n      return result;\n    }\n  };\n\n  return feedback;\n});\n\n  var feedback, matching, scoring, time, time_estimates, zxcvbn;\n\n  matching = require('./matching');\n\ndefine('skylark-zxcvbn/main',[\n  './time_estimates',\n  './feedback',\n  './scoring'\n],function(time_estimates,feedback,scoring){\n\n  time = function() {\n    return (new Date()).getTime();\n  };\n\n  zxcvbn = function(password, user_inputs = []) {\n    var arg, attack_times, i, len, matches, prop, ref, result, sanitized_inputs, start, val;\n    start = time();\n    // reset the user inputs matcher on a per-request basis to keep things stateless\n    sanitized_inputs = [];\n    for (i = 0, len = user_inputs.length; i < len; i++) {\n      arg = user_inputs[i];\n      if ((ref = typeof arg) === \"string\" || ref === \"number\" || ref === \"boolean\") {\n        sanitized_inputs.push(arg.toString().toLowerCase());\n      }\n    }\n    matching.set_user_input_dictionary(sanitized_inputs);\n    matches = matching.omnimatch(password);\n    result = scoring.most_guessable_match_sequence(password, matches);\n    result.calc_time = time() - start;\n    attack_times = time_estimates.estimate_attack_times(result.guesses);\n    for (prop in attack_times) {\n      val = attack_times[prop];\n      result[prop] = val;\n    }\n    result.feedback = feedback.get_feedback(result.score, result.sequence);\n    return result;\n  };\n\n  return zxcvbn;\n});\ndefine('skylark-zxcvbn', ['skylark-zxcvbn/main'], function (main) { return main; });\n\n"]}